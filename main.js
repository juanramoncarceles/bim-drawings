/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/api.js":
/*!********************!*\
  !*** ./src/api.js ***!
  \********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _generics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./generics */ \"./src/generics.js\");\n/* harmony import */ var _drawing__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./drawing */ \"./src/drawing.js\");\n\r\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (class {\r\n\r\n  /****** BASIC GOOGLE API FUNCTIONS ******/\r\n\r\n  /**\r\n   * Retrieves id and name of the files that match the query object.\r\n   * @param {Object} query Object with optional entries: name (str), parentId (str), trashed (bool), excludeName (str), and onlyFolder (bool)\r\n   * @param {String} metadataFields Optional, by default it includes id and name of the file, but any other can be added: 'field, field'\r\n   */\r\n  static listFiles(query, metadataFields) {\r\n    const queryItems = [];\r\n    if (query.name) queryItems.push('name=\\'' + query.name + '\\'');\r\n    if (query.parentId) queryItems.push('\\'' + query.parentId + '\\' in parents');\r\n    if (query.trashed === false) queryItems.push('trashed=false');\r\n    if (query.excludeName) queryItems.push('not name contains \\'' + query.excludeName + '\\'');\r\n    if (query.onlyFolder) queryItems.push('mimeType=\\'application/vnd.google-apps.folder\\'');\r\n    let request = gapi.client.drive.files.list({\r\n      'pageSize': 15,\r\n      'fields': `nextPageToken, files(id, name${metadataFields ? ', ' + metadataFields : ''})`,\r\n      'q': queryItems.join(' and ')\r\n    });\r\n    request.then(res => {\r\n      const files = res.result.files;\r\n      if (files && files.length > 0) {\r\n        console.log(files);\r\n      } else {\r\n        console.log('No files found with this query:', queryItems.join(' and '));\r\n      }\r\n    }, err => {\r\n      console.error(err.body);\r\n    });\r\n    return request;\r\n  }\r\n\r\n\r\n  /**\r\n   * Returns a promise with the contents of the file.\r\n   * @param {String} fileId\r\n   */\r\n  static getFileContent(fileId) {\r\n    let request = gapi.client.drive.files.get({\r\n      fileId: fileId,\r\n      alt: 'media'\r\n    });\r\n    request.then(res => {\r\n      if (res.status === 200)\r\n        console.log('File fetched successfully.');\r\n    }, err => {\r\n      console.error(err.body);\r\n    });\r\n    return request;\r\n  }\r\n\r\n\r\n  /**\r\n   * Returns a promise with the requested data of the file.\r\n   * @param {String} fileId The id of the file to get the data of.\r\n   * @param {String} fields The data to be fetched in format: 'field1, field2'.\r\n   */\r\n  static getFileData(fileId, fields) {\r\n    let request = gapi.client.drive.files.get({\r\n      fileId: fileId,\r\n      fields: fields\r\n    });\r\n    request.then(res => {\r\n      if (res.status === 200) {\r\n        console.log('File data fetched succesfully.');\r\n      }\r\n    }, err => {\r\n      console.error(err);\r\n    });\r\n    return request;\r\n  }\r\n\r\n\r\n  /**\r\n   * Creates a new folder and returns its id.\r\n   * @param {String} title The name of the folder.\r\n   * @param {String} parentId Optional id of the parent folder, if none it will be created on the root.\r\n   */\r\n  static createFolder(title, parentId = 'drive') {\r\n    const body = {\r\n      \"name\": title,\r\n      \"mimeType\": \"application/vnd.google-apps.folder\",\r\n      \"parents\": parentId !== 'drive' ? [parentId] : []\r\n    }\r\n    const request = gapi.client.request({\r\n      'path': 'https://www.googleapis.com/drive/v3/files/',\r\n      'method': 'POST',\r\n      'body': body\r\n    });\r\n    request.then(res => {\r\n      console.log(title + ' folder created. Id: ' + JSON.parse(res.body).id);\r\n    });\r\n    return request;\r\n  }\r\n\r\n\r\n  /**\r\n   * Upload a file to the specific folder.\r\n   * @param {String} fileContent The content of the file as a string.\r\n   * @param {String} fileMimeType The MIME Type of the file. For example: 'application/json'\r\n   * @param {String} fileName Name for the file.\r\n   * @param {String} folderId Id of the parent folder.\r\n   */\r\n  static uploadFile(fileContent, fileMimeType, fileName, folderId) {\r\n    const file = new Blob([fileContent], { type: fileMimeType });\r\n    const metadata = {\r\n      'name': fileName,\r\n      'mimeType': fileMimeType,\r\n      'parents': [folderId]\r\n    };\r\n    const accessToken = gapi.auth.getToken().access_token; // Gapi is used for retrieving the access token.\r\n    const form = new FormData();\r\n    form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));\r\n    form.append('file', file);\r\n\r\n    let request = fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id', {\r\n      method: 'POST',\r\n      headers: new Headers({ 'Authorization': 'Bearer ' + accessToken }),\r\n      body: form\r\n    });\r\n    request.then(res => {\r\n      if (res.ok === true && res.status === 200) {\r\n        console.log('Upload of ' + fileName + ' successful.');\r\n      }\r\n    }, err => {\r\n      console.error(err);\r\n    });\r\n    return request;\r\n  }\r\n\r\n\r\n  /**\r\n   * Update the contents of a file.\r\n   * @param {String} fileContent The content of the file as a string.\r\n   * @param {String} fileMimeType The MIME Type of the file. For example: 'application/json'.\r\n   * @param {String} fileId ID of the file to update its content.\r\n   */\r\n  static updateFileContent(fileContent, fileMimeType, fileId) {\r\n    const file = new Blob([fileContent], { type: fileMimeType });\r\n    const metadata = {\r\n      'mimeType': fileMimeType\r\n    };\r\n    const accessToken = gapi.auth.getToken().access_token; // Gapi is used for retrieving the access token.\r\n    const form = new FormData();\r\n    form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));\r\n    form.append('file', file);\r\n\r\n    let request = fetch(`https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=multipart`, { // Otherwise try uploadType=media\r\n      method: 'PATCH',\r\n      headers: new Headers({ 'Authorization': 'Bearer ' + accessToken }),\r\n      body: form,\r\n    });\r\n    request.then(res => {\r\n      if (res.ok === true && res.status === 200) {\r\n        console.log('Update successful.');\r\n      }\r\n    }, err => {\r\n      console.error(err);\r\n    });\r\n    return request;\r\n  }\r\n\r\n\r\n  /**\r\n   * Version of upload file from documentation that doesnt work.\r\n   * It just creates an untitled empty file in the drive root.\r\n   * @param {*} fileContent \r\n   * @param {*} fileMimeType \r\n   * @param {*} fileName \r\n   * @param {*} folderId \r\n   */\r\n  // static uploadFile2(fileContent, fileMimeType, fileName, folderId) {\r\n  //   const file = new Blob([fileContent], { type: fileMimeType });\r\n  //   const fileMetadata = {\r\n  //     'name': fileName,\r\n  //     'parents': [folderId]\r\n  //   };\r\n  //   const form = new FormData();\r\n  //   form.append('metadata', new Blob([JSON.stringify(fileMetadata)], { type: 'application/json' }));\r\n  //   form.append('file', file);\r\n  //   const media = {\r\n  //     mimeType: fileMimeType,\r\n  //     body: form\r\n  //   };\r\n  //   return gapi.client.drive.files.create({\r\n  //     resource: fileMetadata,\r\n  //     media: media,\r\n  //     fields: 'id'\r\n  //   }, (err, file) => {\r\n  //     if (err) {\r\n  //       // Handle error\r\n  //       console.error(err);\r\n  //     } else {\r\n  //       console.log('File Id: ', file.id);\r\n  //     }\r\n  //   });\r\n  // }\r\n\r\n\r\n  /**\r\n   * Rename a file.\r\n   * @param {String} fileId ID of the file to rename.\r\n   * @param {String} newTitle New title for the file.\r\n   */\r\n  static renameFile(fileId, newTitle) {\r\n    var request = gapi.client.drive.files.update({\r\n      'fileId': fileId,\r\n      'name': newTitle,\r\n      'uploadType': 'media'\r\n    });\r\n    request.then(res => {\r\n      console.log(res);\r\n    }, rej => {\r\n      console.log(rej);\r\n    });\r\n  }\r\n\r\n\r\n  /**\r\n   * Moves a file or folder inside another folder.\r\n   * @param {String} fileId \r\n   * @param {String} parentId \r\n   */\r\n  static moveFileV2(fileId, parentId) {\r\n    const request = gapi.client.request({\r\n      'path': 'https://www.googleapis.com/drive/v2/files/' + fileId + '/parents',\r\n      'method': 'POST',\r\n      'headers': {\r\n        'Content-Type': 'application/json'\r\n      },\r\n      'body': {\r\n        'id': parentId\r\n      }\r\n    });\r\n    request.then(res => {\r\n      console.log(res);\r\n    }, rej => {\r\n      console.log(rej);\r\n    });\r\n    return request;\r\n  }\r\n\r\n\r\n  static moveFile(fileId, parentId) {\r\n    const body = { 'id': parentId };\r\n    const request = gapi.client.drive.parents.insert({\r\n      'fileId': fileId,\r\n      'resource': body\r\n    });\r\n    request.execute(function (resp) { });\r\n  }\r\n\r\n\r\n  /**\r\n   * Permanently delete a file, skipping the trash.\r\n   * @param {String} fileId ID of the file to delete.\r\n   */\r\n  static deleteFile(fileId) {\r\n    let request = gapi.client.drive.files.delete({\r\n      'fileId': fileId\r\n    });\r\n    request.then(res => {\r\n      console.log(res);\r\n    }, rej => {\r\n      console.log(rej);\r\n    });\r\n    return request;\r\n  }\r\n\r\n\r\n  /**\r\n   * NOT WORKING. THIS WOULD ONLY MAKE SENSE IN A SERVER.\r\n   * Subscribes to changes to a file.\r\n   * @param {String} fileId ID of the file to watch.\r\n   */\r\n  // static watchFile(fileId) {\r\n  //   const body = {\r\n  //     \"kind\": \"api#channel\",\r\n  //     \"id\": \"01234567-89ab-cdef-0123456789ab\", // TODO Use a uuid generator\r\n  //     //\"resourceId\": string,\r\n  //     //\"resourceUri\": string,\r\n  //     \"type\": \"web_hook\",\r\n  //     \"address\": \"https://visualarqapp.ramoncarceles.com\"\r\n  //   }\r\n  //   const request = gapi.client.request({\r\n  //     'path': `https://www.googleapis.com/drive/v3/files/${fileId}/watch`,\r\n  //     'method': 'POST',\r\n  //     'body': body\r\n  //   });\r\n  //   request.then(res => {\r\n  //     console.log(res);\r\n  //   });\r\n  //   return request;\r\n  // }\r\n\r\n  // NOT WORKING. THIS WOULD ONLY MAKE SENSE IN A SERVER.\r\n  // static stopWatching(channelId, resourceId) {\r\n  //   const body = {\r\n  //     \"id\": channelId, // Should be the one to stop created previously.\r\n  //     \"resourceId\": resourceId\r\n  //   }\r\n  //   const request = gapi.client.request({\r\n  //     'path': `https://www.googleapis.com/drive/v3/channels/stop`,\r\n  //     'method': 'POST',\r\n  //     'body': body\r\n  //   });\r\n  //   request.then(res => {\r\n  //     console.log(res);\r\n  //   });\r\n  //   return request;\r\n  // }\r\n\r\n\r\n  /**\r\n   * Creates permissions for a specific file.\r\n   * The delay has been added because the GD API doesnt allow to create several permissions at the same time.\r\n   * @param {String} fileId \r\n   * @param {String} emailAddress\r\n   * @param {Number} delay Amount of milliseconds to wait before sending the request.\r\n   */\r\n  static shareFile(fileId, emailAddress, delay = 0) {\r\n    const delayedPromise = new Promise(res => setTimeout(res, delay));\r\n    return delayedPromise.then(res => {\r\n      const request = gapi.client.request({\r\n        'path': 'https://www.googleapis.com/drive/v3/files/' + fileId + '/permissions?sendNotificationEmail=false',\r\n        'method': 'POST',\r\n        'headers': {\r\n          'Content-Type': 'application/json'\r\n        },\r\n        'body': {\r\n          'role': 'writer', // owner, writer, commenter, reader\r\n          'type': 'user',\r\n          'emailAddress': emailAddress\r\n        }\r\n      });\r\n      request.then(res => {\r\n        console.log(res);\r\n      });\r\n      return request;\r\n    });\r\n\r\n    // ORIGINAL CODE WITHOUT DELAY\r\n    // const request = gapi.client.request({\r\n    //   'path': 'https://www.googleapis.com/drive/v3/files/' + fileId + '/permissions',\r\n    //   'method': 'POST',\r\n    //   'headers': {\r\n    //     'Content-Type': 'application/json'\r\n    //   },\r\n    //   'body': {\r\n    //     'role': 'writer', // owner, writer, commenter, reader\r\n    //     'type': 'user',\r\n    //     'emailAddress': emailAddress\r\n    //   }\r\n    // });\r\n    // request.then(res => {\r\n    //   console.log(res);\r\n    // });\r\n    // return request;\r\n  }\r\n\r\n\r\n  /**\r\n   * Deletes permissions for a specific file.\r\n   * @param {String} fileId \r\n   * @param {String} permissionId \r\n   */\r\n  static stopSharingFile(fileId, permissionId) {\r\n    const request = gapi.client.request({\r\n      'path': 'https://www.googleapis.com/drive/v3/files/' + fileId + '/permissions/' + permissionId,\r\n      'method': 'DELETE',\r\n      'headers': {\r\n        'Content-Type': 'application/json'\r\n      }\r\n    });\r\n    request.then(res => {\r\n      console.log(res);\r\n    });\r\n    return request;\r\n  }\r\n\r\n\r\n  /**\r\n   * Gets information about the current user logged in with Google.\r\n   */\r\n  static getUserInfo() {\r\n    const request = gapi.client.drive.about.get({\r\n      fields: 'user'\r\n    });\r\n    request.then(res => {\r\n      console.log(JSON.parse(res.body).user);\r\n    });\r\n    return request;\r\n  }\r\n\r\n\r\n  /**\r\n   * Sends an email indicating that a project as been shared with the receiver.\r\n   * @param {String} sharer Name of the user who shared the project.\r\n   * @param {String} receiver Email address of the receiver.\r\n   * @param {String} projectName The name of the project that has been shared.\r\n   * @param {String} projectId This is required to create the url link to the project.\r\n   */\r\n  static sendSharingProjectEmail(sharer, receiver, projectName, projectId) {\r\n    const request = fetch(`https://us-central1-testgdproject-1570036439931.cloudfunctions.net/sendMail`, {\r\n      method: 'POST',\r\n      headers: {\r\n        'Content-Type': 'application/json'\r\n      },\r\n      body: JSON.stringify({ sharer, receiver, projectName, projectId }) // body data type must match \"Content-Type\" header\r\n    });\r\n    request.then(res => {\r\n      console.log(res);\r\n      // if (res.ok === true && res.status === 200) {\r\n      //   console.log('Send successful.');\r\n      // }\r\n    }, err => {\r\n      console.error(err);\r\n    });\r\n    return request;\r\n  }\r\n\r\n\r\n  /*******************************************************************/\r\n  /***************** APPLICATION SPECIFIC FUNCTIONS ******************/\r\n  /*******************************************************************/\r\n\r\n  /**\r\n   * Creates a new project folder and a subtructure with all the contents of the project on the file.\r\n   * @param {JSON} file The VisualARQ Drawings file created by the exporter.\r\n   * @param {Object} AppData The AppData object that contains info about the app resources.\r\n   * @param {Object} lastUploadedProject Object with the contents of the last uploaded project.\r\n   */\r\n  static async createProject(file, AppData, lastUploadedProject) {\r\n    // Error message will be stored here if needed.\r\n    let errorMsg;\r\n\r\n    const fileContentRaw = await _generics__WEBPACK_IMPORTED_MODULE_0__[\"default\"].readInputFile(file);\r\n    const fileContent = JSON.parse(fileContentRaw);\r\n    console.log('File contents:', fileContent);\r\n    // TODO: Check if the file is valid... minimum required fields? contents?...\r\n\r\n    // The contents of the file if valid will be saved in the lastUploadedProject variable to be used\r\n    // without the need to fetch them. This allows to view the project even without internet connexion.\r\n    lastUploadedProject.name = fileContent.projectInfo.title;\r\n    lastUploadedProject.drawings = fileContent.drawings;\r\n    lastUploadedProject.elementsData = fileContent.elementsData;\r\n\r\n    // Check if the id of the appMainFolder is in the appData global object.\r\n    // If there is none then try to get it, and if there is none one should be created.\r\n    if (!AppData.appMainFolderId) {\r\n      const appMainFolderRes = await this.listFiles({ name: 'VAviewerData', onlyFolder: true, trashed: false });\r\n      const appMainFolderData = appMainFolderRes.result.files;\r\n      if (appMainFolderData && appMainFolderData.length > 0) {\r\n        AppData.appMainFolderId = appMainFolderData[0].id;\r\n      } else {\r\n        // TODO: This should return a promise to know if something went wrong.\r\n        const appMainFolderRes = await this.createFolder('VAviewerData');\r\n        AppData.appMainFolderId = JSON.parse(appMainFolderRes.body).id;\r\n        console.log('No appFolder found, one is going to be created.');\r\n      }\r\n    }\r\n\r\n    let projectFolderId;\r\n\r\n    // Check if there is already a project with this name in the appData object.\r\n    if (AppData.projectsData === undefined || !AppData.projectsData.find(proj => proj.name === fileContent.projectInfo.title)) {\r\n      try {\r\n        const folderCreationPromise = await this.createFolder(fileContent.projectInfo.title, AppData.appMainFolderId);\r\n        projectFolderId = JSON.parse(folderCreationPromise.body).id;\r\n        lastUploadedProject.id = projectFolderId;\r\n        const projectFolderData = { id: projectFolderId, name: fileContent.projectInfo.title };\r\n        if (AppData.projectsData === undefined) {\r\n          AppData.projectsData = [projectFolderData];\r\n        } else if (!AppData.projectsData.find(proj => proj.name === fileContent.projectInfo.title)) {\r\n          AppData.projectsData.push(projectFolderData);\r\n        }\r\n      } catch (err) {\r\n        console.log(err);\r\n        lastUploadedProject.id = 'temporal';\r\n        errorMsg = JSON.parse(err.body).error.message;\r\n      }\r\n    } else if (AppData.projectsData.find(proj => proj.name === fileContent.projectInfo.title)) {\r\n      // TODO: In case not all projects are loaded how to check if there is already one with this name in the backend?\r\n      // TODO: If there is one already, provide an option to propose another name.\r\n      errorMsg = 'No project was created because there is already a project with this name.';\r\n    } else {\r\n      console.error('Unknown error while attempting to create the project folder.');\r\n    }\r\n\r\n    // Create the drawings subfolder only if there are drawings and if the project folder was created succesfully.\r\n    if (projectFolderId && fileContent.drawings) {\r\n      const drawingsFolderPromise = await this.createFolder('drawings', projectFolderId);\r\n      const drawingsFolderId = JSON.parse(drawingsFolderPromise.body).id;\r\n      AppData.projectsData[AppData.projectsData.length - 1].drawingsFolderId = drawingsFolderId;\r\n      // Upload the drawings.\r\n      const drawingsPromises = [];\r\n      for (const drawing in fileContent.drawings) {\r\n        const drawingPromise = this.uploadFile(fileContent.drawings[drawing], 'image/svg+xml', drawing.concat('.svg'), drawingsFolderId);\r\n        drawingsPromises.push(drawingPromise);\r\n      }\r\n      await Promise.all(drawingsPromises)\r\n        .then(res => {\r\n          // TODO: Is it necessary to check if each response was (res.ok === true && res.status === 200)?\r\n          console.log('Drawings uploaded successfully.');\r\n        }, err => {\r\n          console.error(err);\r\n        });\r\n    }\r\n\r\n    // Create the elementsData subfolder only if there is data and if the project folder was created succesfully.\r\n    if (projectFolderId && fileContent.elementsData) {\r\n      const elementsDataFolderPromise = await this.createFolder('elementsData', projectFolderId);\r\n      const elementsDataFolderId = JSON.parse(elementsDataFolderPromise.body).id;\r\n      AppData.projectsData[AppData.projectsData.length - 1].elementsDataFolderId = elementsDataFolderId;\r\n      // Upload the elements data files.\r\n      const elementsDataPromises = [];\r\n      for (const elementData in fileContent.elementsData) {\r\n        const elementDataPromise = this.uploadFile(JSON.stringify(fileContent.elementsData[elementData]), 'application/json', elementData.concat('.json'), elementsDataFolderId);\r\n        elementsDataPromises.push(elementDataPromise);\r\n      }\r\n      await Promise.all(elementsDataPromises)\r\n        .then(res => {\r\n          // TODO: Is it necessary to check if each response was (res.ok === true && res.status === 200)?\r\n          console.log('ElementsData files uploaded successfully.');\r\n        }, err => {\r\n          console.error(err);\r\n        });\r\n    }\r\n\r\n    // TODO: Check in more detail if the project was created successfully.\r\n    if (projectFolderId) {\r\n      console.log('Upload successful. Uploaded ' + Object.keys(fileContent.drawings).length + ' drawings.');\r\n      return { id: projectFolderId, name: fileContent.projectInfo.title };\r\n    } else {\r\n      // TODO: If the project upload fails the project folder, if created, should be deleted.\r\n      // TODO: Create message with content: Retry again or work offline with the uploaded project.\r\n      return Promise.reject(new Error('Project upload failed. ' + errorMsg));\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Lists the project items.\r\n   * TODO: Limit the amount of projects to fetch.\r\n   * @param {Object} AppData The AppData object that contains info about the app resources.\r\n   */\r\n  static async listProjectItems(AppData) {\r\n    // Gets the id of the app folder using its name if it was not already in the appData object.\r\n    if (!AppData.appMainFolderId) {\r\n      const appMainFolderRes = await this.listFiles({ name: 'VAviewerData', onlyFolder: true, trashed: false });\r\n      const appMainFolderData = appMainFolderRes.result.files;\r\n      if (appMainFolderData && appMainFolderData.length > 0) {\r\n        AppData.appMainFolderId = appMainFolderData[0].id;\r\n      } else {\r\n        console.log('No appFolder found.');\r\n        return Promise.reject(new Error('No appFolder found.'));\r\n      }\r\n    }\r\n\r\n    // Gets the project folders names and ids.\r\n    const projectsFoldersRes = await this.listFiles({ parentId: AppData.appMainFolderId, onlyFolder: true, excludeName: 'appSettings', trashed: false }, 'shared, permissions');\r\n    let newProjects;\r\n    const projectsFoldersData = projectsFoldersRes.result.files;\r\n    if (projectsFoldersData && projectsFoldersData.length > 0) {\r\n      if (AppData.projectsData === undefined) {\r\n        newProjects = projectsFoldersData;\r\n        AppData.projectsData = newProjects;\r\n      } else if (Array.isArray(AppData.projectsData)) {\r\n        newProjects = projectsFoldersRes.result.files.filter(newProj => AppData.projectsData.find(proj => proj.id === newProj.id) === undefined);\r\n        newProjects.forEach(proj => {\r\n          AppData.projectsData.push(proj);\r\n        });\r\n      }\r\n    }\r\n    console.assert(AppData.projectsData.length > 0, 'There are no project folders.');\r\n\r\n    // Gets the id of the appSettings folder.\r\n    const appSettFolderRes = await this.listFiles({ parentId: AppData.appMainFolderId, name: 'appSettings', onlyFolder: true });\r\n    const appSettFolderData = appSettFolderRes.result.files;\r\n    if (appSettFolderData && appSettFolderData.length > 0) {\r\n      AppData.appSettingsFolderId = appSettFolderData[0].id;\r\n    } else {\r\n      console.log('No settings folder found.');\r\n    }\r\n\r\n    // Gets the id of the projectsThumbs folder.\r\n    const thumbsFolderRes = await this.listFiles({ parentId: AppData.appSettingsFolderId, name: 'projectsThumbs', onlyFolder: true });\r\n    const thumbsFolderData = thumbsFolderRes.result.files;\r\n    if (thumbsFolderData && thumbsFolderData.length > 0) {\r\n      AppData.thumbsFolderId = thumbsFolderData[0].id;\r\n    } else {\r\n      console.log('No thumbs folder found.');\r\n    }\r\n\r\n    // Gets the data of each thumbnail and assign it to its corresponding project.\r\n    const imgRes = await this.listFiles({ parentId: AppData.thumbsFolderId });\r\n    const imgData = imgRes.result.files;\r\n    AppData.projectsData.forEach(proj => {\r\n      const projectThumbData = imgData.find(img => proj.id === img.name.replace('.jpg', ''));\r\n      if (projectThumbData) {\r\n        proj.thumbId = projectThumbData.id;\r\n      }\r\n    });\r\n    console.assert(imgData.length > 0, 'There are no thumbnails.');\r\n\r\n    // TODO: Missing the management of an error while listing the projects.\r\n\r\n    // If all the required data about the projects was fetched successfully it is returned.\r\n    return newProjects;\r\n  }\r\n\r\n\r\n  /**\r\n   * Fetches the project contents. Specifically the id and the name of all the drawings and elementsData files.\r\n   * It only fetches the resources that are not already in the appData object.\r\n   * TODO: Improve the detection of resources that should be fetched. Currently if there is already any project\r\n   * data for that category (e.g: drawings) in the front it doenst fetch any new file of that category.\r\n   * @param {String} projectId The id of the project.\r\n   * @param {Object} AppData The AppData object that contains info about the app resources.\r\n   */\r\n  static async fetchProject(projectId, AppData) {\r\n    console.log('Fetching project: ' + projectId);\r\n\r\n    let projectIndex;\r\n    // In case the projectsData entry is still undefined this will be the first project to be fetched.\r\n    // This will happen when someone access a project directly with its id in the url.\r\n    if (AppData.projectsData === undefined) {\r\n      const projectNameRes = await this.getFileData(projectId, 'name, trashed');\r\n      if (!JSON.parse(projectNameRes.body).trashed) {\r\n        AppData.projectsData = [{ id: projectId, name: JSON.parse(projectNameRes.body).name }];\r\n        projectIndex = 0;\r\n      }\r\n    } else if (projectId !== 'temporal') {\r\n      projectIndex = AppData.projectsData.findIndex(proj => proj.id === projectId);\r\n    }\r\n\r\n    // If there is no data for projectSettings.json file in the appData yet fetch it.\r\n    if (projectIndex >= 0 && !AppData.projectsData[projectIndex].projSettings) {\r\n      const projSettingsRes = await this.listFiles({ parentId: projectId, name: 'projectSettings.json' });\r\n      const projSettingsData = projSettingsRes.result.files;\r\n      if (projSettingsData && projSettingsData.length > 0) {\r\n        const projSettingsContentRes = await this.getFileContent(projSettingsData[0].id);\r\n        AppData.projectsData[projectIndex].projSettings = projSettingsContentRes.body;\r\n      } else {\r\n        console.log('No projectSettings.json found.');\r\n      }\r\n    }\r\n\r\n    // If there is no data for drawings already fetch the id of the drawings folder and the name and id of each one.\r\n    if (projectIndex >= 0 && !AppData.projectsData[projectIndex].drawings) {\r\n      const drawingsFolderRes = await this.listFiles({ parentId: projectId, onlyFolder: true, name: 'drawings' });\r\n      const drawingsFolderData = drawingsFolderRes.result.files;\r\n      if (drawingsFolderData && drawingsFolderData.length > 0) {\r\n        const drawingsRes = await this.listFiles({ parentId: drawingsFolderData[0].id, trashed: false });\r\n        AppData.projectsData[projectIndex].drawings = [];\r\n        drawingsRes.result.files.forEach(drawing => {\r\n          if (drawing.name === 'drawingsStyles.css') {\r\n            AppData.projectsData[projectIndex].drawingsStylesId = drawing.id;\r\n          } else {\r\n            AppData.projectsData[projectIndex].drawings.push(new _drawing__WEBPACK_IMPORTED_MODULE_1__[\"Drawing\"](drawing.name.replace(/.svg$/, ''), drawing.id));\r\n          }\r\n        });\r\n      } else {\r\n        console.log('No drawings folder found.');\r\n      }\r\n    }\r\n\r\n    // If there is no data for elementsData already fetch the id of the elementsData folder and the name and id of each one.\r\n    if (projectIndex >= 0 && !AppData.projectsData[projectIndex].elementsData) {\r\n      const elementsDataFolderRes = await this.listFiles({ parentId: projectId, onlyFolder: true, name: 'elementsData' });\r\n      const elementsDataFolderData = elementsDataFolderRes.result.files;\r\n      if (elementsDataFolderData && elementsDataFolderData.length > 0) {\r\n        const elementsDataRes = await this.listFiles({ parentId: elementsDataFolderData[0].id, trashed: false });\r\n        AppData.projectsData[projectIndex].elementsData = elementsDataRes.result.files;\r\n      } else {\r\n        console.log('No elementsData folder found.');\r\n      }\r\n    }\r\n\r\n    // If there is no data for comments in the appData yet fetch it.\r\n    if (projectIndex >= 0 && !AppData.projectsData[projectIndex].comments) {\r\n      // TODO: Could be that the id of the file is already in the projectsData and listFiles is no necessary?\r\n      const commentsRes = await this.listFiles({ parentId: projectId, name: 'comments.json', trashed: false });\r\n      const commentsData = commentsRes.result.files;\r\n      if (commentsData && commentsData.length > 0) {\r\n        AppData.projectsData[projectIndex].commentsFileId = commentsData[0].id;\r\n        const commentsContentRes = await this.getFileContent(commentsData[0].id);\r\n        AppData.projectsData[projectIndex].comments = JSON.parse(commentsContentRes.body);\r\n      } else {\r\n        console.log('No comments.json file found.');\r\n      }\r\n    }\r\n\r\n    // If there is no data for images already fetch the id of the images folder and the name and id of each one.\r\n    if (projectIndex >= 0 && !AppData.projectsData[projectIndex].images) {\r\n      const imagesFolderRes = await this.listFiles({ parentId: projectId, onlyFolder: true, name: 'images' });\r\n      const imagesFolderData = imagesFolderRes.result.files;\r\n      if (imagesFolderData && imagesFolderData.length > 0) {\r\n        const imagesRes = await this.listFiles({ parentId: imagesFolderData[0].id });\r\n        AppData.projectsData[projectIndex].images = imagesRes.result.files;\r\n      } else {\r\n        console.log('No images folder found.');\r\n      }\r\n    }\r\n\r\n    if (projectIndex >= 0) {\r\n      console.log('Project resources fetched succesfully.');\r\n      return AppData.projectsData[projectIndex];\r\n    } else {\r\n      return Promise.reject(new Error('Project resources could not be fetched.'));\r\n    }\r\n  }\r\n\r\n});\n\n//# sourceURL=webpack:///./src/api.js?");

/***/ }),

/***/ "./src/app.js":
/*!********************!*\
  !*** ./src/app.js ***!
  \********************/
/*! exports provided: Application */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Application\", function() { return Application; });\n/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api */ \"./src/api.js\");\n/* harmony import */ var _workspace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./workspace */ \"./src/workspace.js\");\n/* harmony import */ var _projectData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./projectData */ \"./src/projectData.js\");\n/* harmony import */ var _generics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./generics */ \"./src/generics.js\");\n/* harmony import */ var _appTools_addComment__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./appTools/addComment */ \"./src/appTools/addComment.js\");\n/* harmony import */ var _appTools_elementData__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./appTools/elementData */ \"./src/appTools/elementData.js\");\n/* harmony import */ var _shareProject__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./shareProject */ \"./src/shareProject.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass Application {\r\n  constructor() {\r\n    this.appMainFolderId = undefined;\r\n    // projectsData: Array of objects with data like 'name' and 'id' of the projects.\r\n    this.projectsData = undefined;\r\n    this.appSettingsFolderId = undefined;\r\n    this.thumbsFolderId = undefined;\r\n    // If a user is logged it profile info is stored here.\r\n    this.userInfo = undefined;\r\n    this.userInfoContainer = document.getElementById('user-info');\r\n    // The current workspace object will be referenced here.\r\n    this.workspace = undefined;\r\n    this.lastUploadedProject = new _projectData__WEBPACK_IMPORTED_MODULE_2__[\"ProjectData\"]();\r\n    // Stores the active item in the projects list.\r\n    this.previousActiveItem;\r\n    this.projectsListBtn = document.getElementById('projectsListBtn');\r\n    this.drawingsContainer = document.getElementById('drawingsContainer');\r\n    this.drawingsBtns = document.getElementById('drawingsBtns');\r\n    this.toolbarsContainer = document.getElementById('toolbarsContainer');\r\n    // Modal dialog.\r\n    this.modalDialogContainer = document.getElementById('modalDialogContainer');\r\n    this.modalDialogContent = this.modalDialogContainer.querySelector('.modal-content');\r\n    this.modalDialogsStorage = document.getElementById('modalDialogsStorage');\r\n    this.closeModalBtn = document.getElementById('closeModalBtn');\r\n    this.closeModalDialog = this.closeModalDialog.bind(this);\r\n    this.closeModalBtn.onclick = this.closeModalDialog;\r\n    // Viewport message.\r\n    this.viewportMessage = document.getElementById('viewportMessage');\r\n    // Projects list.\r\n    this.projectsListContainer = document.getElementById('projectsListContainer');\r\n    this.projectsList = document.getElementById('projectsList');\r\n    this.closeProjectsListBtn = document.getElementById('closeProjectsListBtn');\r\n    // Main panel.\r\n    this.mainPanel = document.getElementById('mainPanel');\r\n    this.panelsStorage = document.getElementById('panelsStorage');\r\n    this.saveBtn = document.getElementById('saveBtn');\r\n    this.saveCommentsData = this.saveCommentsData.bind(this);\r\n    this.saveBtn.addEventListener('click', this.saveCommentsData);\r\n    this.closeProjectsList = this.closeProjectsList.bind(this);\r\n    this.projectsListBtn.onclick = () => {\r\n      if (this.projectsListBtn.dataset.open === 'true') {\r\n        this.closeProjectsList();\r\n      } else if (this.projectsListBtn.dataset.open === 'false') {\r\n        this.openProjectsList();\r\n      }\r\n    }\r\n    this.closeProjectsListBtn.addEventListener('click', this.closeProjectsList);\r\n    this.goToProject = this.goToProject.bind(this);\r\n    this.projectsList.addEventListener('click', this.goToProject);\r\n    /********************* Upload project form *********************/\r\n    this.uploadFileForm = document.getElementById('uploadFileForm');\r\n    this.fileInput = document.getElementById('fileInput');\r\n    this.submitFileBtn = this.uploadFileForm.querySelector('button[type=\"submit\"]');\r\n    // Show the upload project form.\r\n    document.getElementById('newProjectBtn').addEventListener('click', () => {\r\n      this.showModalDialog(this.uploadFileForm);\r\n      this.modalDialogContainer.classList.add('grayTranslucent');\r\n    });\r\n    // Hide the upload project form.\r\n    document.getElementById('closeUploadForm').addEventListener('click', () => {\r\n      this.closeModalDialog(this.uploadFileForm);\r\n      this.modalDialogContainer.classList.remove('grayTranslucent');\r\n    });\r\n    // Listen to file input changes.\r\n    this.fileInput.addEventListener('change', () => {\r\n      if (this.fileInput.files.length > 0) {\r\n        this.fileInput.nextElementSibling.innerHTML = this.fileInput.files[0].name;\r\n        this.submitFileBtn.classList.remove('disabled');\r\n      } else {\r\n        this.fileInput.nextElementSibling.innerHTML = 'Choose a file';\r\n        this.submitFileBtn.classList.add('disabled');\r\n      }\r\n    });\r\n    // Submit file logic.\r\n    this.uploadFileForm.onsubmit = e => {\r\n      e.preventDefault();\r\n      // Set loading state on UI.\r\n      document.getElementById('loadingFile').style.display = 'unset';\r\n      this.submitFileBtn.classList.add('disabled');\r\n      this.submitFileBtn.innerHTML = 'Uploading file';\r\n      this.fileInput.nextElementSibling.style.display = 'none';\r\n      const file = e.target.elements[\"file\"].files[0];\r\n      // TODO: Show some real progress while creating the project.\r\n      _api__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createProject(file, this, this.lastUploadedProject).then(res => {\r\n        this.updateProjectsList(res);\r\n        this.closeModalDialog(this.uploadFileForm);\r\n        this.showMessage('success', 'Project uploaded successfully.');\r\n        this.fileInput.value = '';\r\n        // Reset upload form UI.\r\n        document.getElementById('loadingFile').style.display = 'none';\r\n        this.fileInput.nextElementSibling.innerHTML = 'Choose a file';\r\n        this.submitFileBtn.innerHTML = 'Upload';\r\n        this.fileInput.nextElementSibling.style.display = 'unset';\r\n      }, err => {\r\n        this.closeModalDialog(this.uploadFileForm);\r\n        this.updateProjectsList(this.lastUploadedProject);\r\n        console.error(err);\r\n      });\r\n    }\r\n    /********************* Share project form *********************/\r\n    this.shareProjectDialog = new _shareProject__WEBPACK_IMPORTED_MODULE_6__[\"ShareProject\"](document.getElementById('shareProjectDialog'), this);\r\n    /********************** Message container **********************/\r\n    this.messageContainer = document.getElementById('messageContainer');\r\n    this.closeMessage = this.closeMessage.bind(this);\r\n    this.messageContainer.querySelector('button').onclick = this.closeMessage;\r\n    this.messageTimerId;\r\n    /*************** Projects list items distribution **************/\r\n    window.onresize = this.adjustItems;\r\n    /**************** Tools buttons event listeners ****************/\r\n    // TODO: This would make more sense as part of the workspace ?\r\n    document.getElementById('tool-4').addEventListener('click', (e) => this.workspace.manageTools(e, _appTools_elementData__WEBPACK_IMPORTED_MODULE_5__[\"ElementData\"], 'elementsDataTool'));\r\n    document.getElementById('tool-5').addEventListener('click', (e) => this.workspace.manageTools(e, _appTools_addComment__WEBPACK_IMPORTED_MODULE_4__[\"AddComment\"], 'commentsTool'));\r\n\r\n\r\n    // TESTS. TO DELETE\r\n    document.getElementById('viewDeviceToken').onclick = () => getMessagingToken();\r\n    document.getElementById('saveDeviceToken').onclick = () => saveMessagingDeviceToken();\r\n    document.getElementById('sendEmail').onclick = () => _api__WEBPACK_IMPORTED_MODULE_0__[\"default\"].sendSharingProjectEmail('Pepi', 'juanramoncarceles@gmail.com', 'Casa', '94w02u');\r\n    // this.sendNotification = document.getElementById('sendNotification');\r\n    // this.sendNotification.onclick = () => {\r\n    //   // What ?\r\n    // }\r\n  }\r\n\r\n\r\n  /**\r\n   * Stores the current logged user info as a property of the app and\r\n   * populates the UI with the user info.\r\n   */\r\n  async setUserInfo() {\r\n    const userInfoRes = await _api__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getUserInfo();\r\n    // An object with at least displayName, photoLink and emailAddress.\r\n    const user = JSON.parse(userInfoRes.body).user;\r\n    this.userInfo = user;\r\n    this.userInfoContainer.innerHTML = `\r\n      <img src=${this.userInfo.photoLink}>\r\n      <span>\r\n        <span>${this.userInfo.displayName}</span><span class=\"email\">${this.userInfo.emailAddress}</span>\r\n      </span>`;\r\n  }\r\n\r\n\r\n  /**\r\n   * Saves the comments data created using the comments array from the current workspace.\r\n   * It creates the file if it still doesnt exist or updates its contents if it exists.\r\n   */\r\n  async saveCommentsData() {\r\n    if (this.workspace && this.workspace.commentsChangesUnsaved) {\r\n      // TODO: Show viewport waiting message.\r\n      let savingSuccessful;\r\n      // Collect the data to save in backend.\r\n      const dataToSave = [];\r\n      this.workspace.comments.forEach(comment => {\r\n        dataToSave.push({\r\n          elementId: comment.elementId,\r\n          content: comment.content\r\n        });\r\n      });\r\n      const jsonDataToSave = JSON.stringify(dataToSave);\r\n      // If there is id for the comments.json file.\r\n      if (!this.workspace.commentsFileId) {\r\n        // Create the file with the contents and get the id of it.\r\n        // TODO: The current uploadFile doesnt return the id of the created file.\r\n        // This makes it longer with a second request to get the id of it.\r\n        // There is no example on the Google Drive API documentation for browser.\r\n        const commentsFileCreationRes = await _api__WEBPACK_IMPORTED_MODULE_0__[\"default\"].uploadFile(jsonDataToSave, 'application/json', 'comments.json', this.workspace.projectId);\r\n        if (commentsFileCreationRes.ok && commentsFileCreationRes.status === 200) {\r\n          const commentsFileRes = await _api__WEBPACK_IMPORTED_MODULE_0__[\"default\"].listFiles({ name: 'comments.json', parentId: this.workspace.projectId, trashed: false });\r\n          const commentsFileData = commentsFileRes.result.files;\r\n          if (commentsFileData && commentsFileData.length === 1) {\r\n            this.workspace.commentsFileId = commentsFileData[0].id;\r\n            savingSuccessful = true;\r\n            console.log('comments.json created: ' + this.workspace.commentsFileId);\r\n          } else {\r\n            savingSuccessful = false;\r\n            // TODO: Delete existing created file/s with name 'comments.json', if there is no id then use the name.\r\n          }\r\n        }\r\n      } else {\r\n        // Update the existing comments.json file.\r\n        const commentsFileUpdateRes = await _api__WEBPACK_IMPORTED_MODULE_0__[\"default\"].updateFileContent(jsonDataToSave, 'application/json', this.workspace.commentsFileId);\r\n        if (commentsFileUpdateRes.ok && commentsFileUpdateRes.status === 200) {\r\n          savingSuccessful = true;\r\n        }\r\n      }\r\n      // TODO: Remove viewport waiting message.\r\n      if (savingSuccessful) {\r\n        // TODO: Show message indicating success.\r\n        this.commentsChangesUnsaved = false;\r\n        this.saveBtn.classList.remove('enabled');\r\n        this.saveBtn.classList.add('disabled');\r\n        console.log('Data saved successfully.');\r\n      } else {\r\n        // TODO: message something went wrong.\r\n        console.log('Something went wrong trying to save. Retry again.');\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  /************************ THE PROJECTS LIST ************************/\r\n\r\n  /**\r\n   * Selects a project from the list and manages its resources before opening the project.\r\n   * @param {Event} e Click event.\r\n   */\r\n  goToProject(e) {\r\n    const projectItem = e.target.closest('[data-proj-id]');\r\n    if (projectItem === null) {\r\n      return;\r\n    }\r\n    // If it is the current project close the list window.\r\n    if (this.workspace && this.workspace.projectId === projectItem.dataset.projId) {\r\n      return;\r\n    }\r\n    // TODO: If there have been changes in the project ask to save or discard them before closing it.\r\n    // TODO: If it was an offline project try to sync it before closing it. The id would be 'temporal' and the contents in currentProject\r\n    if (projectItem.dataset.projId === this.lastUploadedProject.id) {\r\n      if (this.lastUploadedProject.id === 'temporal') {\r\n        console.log('Show a message indicating that the project can be accessed but in viewer mode because it couldnt be saved.');\r\n      }\r\n      this.openProject(this.lastUploadedProject);\r\n      if (this.previousActiveItem) {\r\n        this.previousActiveItem.classList.remove('current');\r\n      }\r\n      projectItem.classList.add('current');\r\n      this.previousActiveItem = projectItem;\r\n      this.projectsListBtn.style.display = 'unset';\r\n    } else {\r\n      this.showViewportDialog('loader', `Loading project ${projectItem.dataset.name}`);\r\n      _api__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fetchProject(projectItem.dataset.projId, this)\r\n        .then(res => {\r\n          this.openProject(res);\r\n          if (this.previousActiveItem) {\r\n            this.previousActiveItem.classList.remove('current');\r\n          }\r\n          projectItem.classList.add('current');\r\n          this.previousActiveItem = projectItem;\r\n          this.projectsListBtn.style.display = 'unset';\r\n          this.hideViewportMessage();\r\n        }, err => {\r\n          console.log(err);\r\n        });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates a workspace with the provided project.\r\n   * @param {Object} project Data of the project: id, name, drawings ids and elementsData files ids.\r\n   */\r\n  openProject(project) {\r\n    if (this.workspace) {\r\n      this.workspace.close();\r\n    }\r\n    this.workspace = new _workspace__WEBPACK_IMPORTED_MODULE_1__[\"Workspace\"](project, this);\r\n    this.projectsListContainer.style.display = 'none';\r\n    history.replaceState({ projectTitle: project.name }, project.name, \"?id=\" + project.id); // encodeURIComponent ? use pushState() ?\r\n  }\r\n\r\n  /**\r\n   * Closes the projects list and shows the current project toolbar.\r\n   * Sets the state of the ui as projects list closed.\r\n   */\r\n  closeProjectsList() {\r\n    this.projectsListContainer.style.display = 'none';\r\n    this.drawingsBtns.style.display = 'unset';\r\n    this.toolbarsContainer.style.display = 'flex';\r\n    this.projectsListBtn.dataset.open = 'false';\r\n  }\r\n\r\n  /**\r\n   * Opens the list of projects container and fetches projects if required.\r\n   * Sets the state of the ui as projects list closed.\r\n   */\r\n  openProjectsList() {\r\n    if (this.workspace === undefined) {\r\n      this.closeProjectsListBtn.classList.add('hidden');\r\n    } else {\r\n      this.closeProjectsListBtn.classList.remove('hidden');\r\n    }\r\n    this.projectsListContainer.style.display = 'block';\r\n    this.projectsListBtn.dataset.open = 'true';\r\n    // Hide the drawings and tools buttons\r\n    this.drawingsBtns.style.display = 'none';\r\n    this.toolbarsContainer.style.display = 'none';\r\n    // If there is no projectsData or if there is only one fetch projects.\r\n    if (this.projectsData === undefined || this.projectsData.length <= 1) {\r\n      this.showViewportDialog('loader', 'Loading projects');\r\n      _api__WEBPACK_IMPORTED_MODULE_0__[\"default\"].listProjectItems(this).then(res => {\r\n        this.createHTMLProjectsList(res);\r\n        // Set the 'current' class in the current project.\r\n        this.projectsList.childNodes.forEach(proj => {\r\n          if (proj.dataset && proj.dataset.projId === this.workspace.projectId) {\r\n            proj.classList.add('current');\r\n            this.previousActiveItem = proj;\r\n          }\r\n        });\r\n        this.hideViewportMessage();\r\n      }, rej => {\r\n        this.projectsList.innerHTML = '<p class=\"empty-msg\">There are no projects. Upload one!</p>';\r\n        this.hideViewportMessage();\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create an HTML element with the project data provided.\r\n   * @param {Object} projData Object with name, id and optional thumbId entries.\r\n   */\r\n  createProjectItem(projData) {\r\n    const projItem = document.createElement('button');\r\n    // Projects that have been uploaded but not send to the backend have an id of 'temporal'.\r\n    if (projData.id === 'temporal') {\r\n      projItem.classList.add('unsync');\r\n    }\r\n    projItem.dataset.projId = projData.id;\r\n    projItem.dataset.name = projData.name;\r\n    projItem.classList.add('projectItem');\r\n    let projItemContent = [];\r\n    if (projData.shared) {\r\n      projItemContent.push('<img class=\"sharedIcon\" src=\"src/assets/icons/shareIcon.svg\">');\r\n    }\r\n    if (projData.thumbId) {\r\n      projItemContent.push(`<img class=\"thumb\" src=\"https://drive.google.com/uc?id=${projData.thumbId}\">`);\r\n    } else {\r\n      projItemContent.push(`<svg class=\"thumb\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"-100 -50 350 210\"><path d=\"M143,10.44H65.27V7a7,7,0,0,0-7-7H7A7,7,0,0,0,0,7V103a7,7,0,0,0,7,7H65V70.18H85V110h58a7,7,0,0,0,7-7V17.41A7,7,0,0,0,143,10.44ZM125,53.49H105v-20h20Z\" style=\"fill:#e6e6e6\"/></svg>`);\r\n    }\r\n    projItemContent.push(`<h4>${projData.name}</h4>`);\r\n    projItem.innerHTML = projItemContent.join('');\r\n    return projItem;\r\n  }\r\n\r\n  /**\r\n   * Receives an array of projects data and creates and appends the HTML items.\r\n   * @param {Array} projectsData The project objects with the name, id and optional thumbId entries.\r\n   */\r\n  createHTMLProjectsList(projectsData) {\r\n    projectsData.forEach(proj => {\r\n      const projectItem = this.createProjectItem(proj);\r\n      this.projectsList.appendChild(projectItem);\r\n    });\r\n    this.adjustItems();\r\n  }\r\n\r\n  /**\r\n   * Adjusts the position of project items in the container.\r\n   */\r\n  adjustItems() {\r\n    const itemsH = getComputedStyle(this.projectsList).getPropertyValue('--items-h');\r\n    const itemsTotal = this.projectsList.children.length;\r\n    this.projectsList.style.setProperty('--remaining-items', (Math.ceil(itemsTotal / itemsH) * itemsH) - itemsTotal);\r\n  }\r\n\r\n  /**\r\n   *  Adds a new HTML element item to the list of projects.\r\n   * @param {Object} projData Object with name, id and optional thumbId entries.\r\n   */\r\n  updateProjectsList(projData) {\r\n    const projectItem = this.createProjectItem(projData);\r\n    // Remove the 'no projects yet' message if it is the first.\r\n    if (this.projectsData.length <= 1) {\r\n      this.projectsList.querySelector('.empty-msg').remove();\r\n    }\r\n    this.projectsList.prepend(projectItem);\r\n    this.adjustItems();\r\n  }\r\n\r\n\r\n  /*********************** MESSAGE CONTAINER ***********************/\r\n  /*\r\n   * A message that works as a feedback and that doesnt interrupt.\r\n   */\r\n\r\n  /**\r\n  * Disaplays feedback message.\r\n  * @param {String} message \r\n  * @param {String} type Use keywords 'success', 'warning' or 'error' to specify the type of message.\r\n  * \r\n  */\r\n  showMessage(type, message, timer) {\r\n    // If the data-type attr has value is because the message is still open.\r\n    if (this.messageContainer.dataset.type !== '') {\r\n      this.messageContainer.classList.remove(this.messageContainer.dataset.type);\r\n      if (this.messageTimerId) {\r\n        clearTimeout(this.messageTimerId);\r\n        this.messageTimerId = undefined;\r\n      }\r\n    } else {\r\n      this.messageContainer.style.display = 'flex';\r\n    }\r\n    this.messageContainer.dataset.type = type;\r\n    this.messageContainer.querySelector('p').innerText = message;\r\n    switch (type) {\r\n      case 'success':\r\n        this.messageContainer.classList.add('success');\r\n        break;\r\n      case 'warning':\r\n        this.messageContainer.classList.add('warning');\r\n        break;\r\n      case 'error':\r\n        this.messageContainer.classList.add('error');\r\n        break;\r\n    }\r\n    if (timer) {\r\n      this.messageTimerId = setTimeout(() => this.closeMessage(), timer);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Closes the message container and removes the class that gives the type of message style.\r\n   */\r\n  closeMessage() {\r\n    this.messageContainer.style.display = 'none';\r\n    this.messageContainer.classList.remove(this.messageContainer.dataset.type);\r\n    this.messageContainer.dataset.type = '';\r\n    if (this.messageTimerId) {\r\n      clearTimeout(this.messageTimerId);\r\n      this.messageTimerId = undefined;\r\n    }\r\n  }\r\n\r\n\r\n  /*********************** VIEWPORT MESSAGES ***********************/\r\n  /*\r\n   * A message on the middle of the viewport that interrupts.\r\n   */\r\n\r\n  /**\r\n   * Manages the creation of a message on the viewport.\r\n   * @param {String} type Values 'loader' or 'action'. If action an object with a function reference and a name should be provided.\r\n   * @param {String} message \r\n   * @param {Array} actions Array of objects with name and function entries.\r\n   */\r\n  showViewportDialog(type, message, actions) {\r\n    if (this.viewportMessage.querySelector('.btns-container')) {\r\n      this.viewportMessage.querySelectorAll('.btns-container > button').forEach(btn => btn.onclick = null);\r\n    }\r\n    _generics__WEBPACK_IMPORTED_MODULE_3__[\"default\"].emptyNode(this.viewportMessage);\r\n    // Create the new content.\r\n    const innerContainer = document.createElement('div');\r\n    if (type === 'loader') {\r\n      innerContainer.innerHTML = `<p>${message}</p><svg class=\"svg-loader\"><use href=\"#vaLoader\"/></svg>`;\r\n    } else if (type === 'action') {\r\n      innerContainer.innerHTML = `<p>${message}</p>`;\r\n      const btnsContainer = document.createElement('div');\r\n      btnsContainer.classList.add('btns-container');\r\n      actions.forEach(action => {\r\n        const button = document.createElement('button');\r\n        button.innerHTML = action.name;\r\n        button.classList.add('buttonBase', 'light');\r\n        button.onclick = action.function;\r\n        btnsContainer.appendChild(button);\r\n      });\r\n      innerContainer.appendChild(btnsContainer);\r\n    } else if (type === 'message') { // Is this one useful? Maybe with a setTimeout?\r\n      innerContainer.innerHTML = '<p>' + message + '</p>';\r\n    }\r\n    this.viewportMessage.appendChild(innerContainer);\r\n    this.viewportMessage.classList.add('active');\r\n  }\r\n\r\n  /**\r\n   * Hides the viewport message if visible.\r\n   */\r\n  hideViewportMessage() {\r\n    this.viewportMessage.classList.remove('active');\r\n  }\r\n\r\n\r\n  /********************* MODAL DIALOGS *********************/\r\n  /*\r\n   * All modal dialog contents are stored in a container and fetched when needed.\r\n   */\r\n\r\n  /**\r\n   * Shows the modal dialog provided from the same document.\r\n   * @param {HTMLElement} content Reference to the outer HTML element of the dialog.\r\n   */\r\n  showModalDialog(content) {\r\n    this.modalDialogContent.appendChild(content);\r\n    this.modalDialogContainer.style.display = 'flex';\r\n  }\r\n\r\n  /**\r\n   * Hides the current modal dialog.\r\n   */\r\n  closeModalDialog() {\r\n    const content = this.modalDialogContent.firstElementChild;\r\n    this.modalDialogContainer.style.display = 'none';\r\n    this.modalDialogsStorage.appendChild(content);\r\n  }\r\n\r\n\r\n  /********************* START THE APPLICATION *********************/\r\n\r\n  /**\r\n   * Starts the app, if a project id is provided it will start from that projec view.\r\n   * If no project id is provided it will start from the projects list view.\r\n   * @param {String} projectId Optional projectId to start.\r\n   */\r\n  start(projectId) {\r\n    // Show the app interface.\r\n    document.querySelector('header').style.display = 'flex';\r\n    document.querySelector('main').style.display = 'block';\r\n    // Start options depending if there is a projectId.\r\n    if (projectId) {\r\n      this.showViewportDialog('loader', 'Loading project');\r\n      _api__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fetchProject(projectId, this)\r\n        .then(res => {\r\n          this.workspace = new _workspace__WEBPACK_IMPORTED_MODULE_1__[\"Workspace\"](res, this);\r\n          this.createHTMLProjectsList([res]);\r\n          this.projectsListBtn.style.display = 'unset';\r\n          this.hideViewportMessage();\r\n        }, rej => {\r\n          console.log(rej);\r\n          const errorMessage = rej.body === undefined ? rej : `Message: ${JSON.parse(rej.body).error.message} Code: ${JSON.parse(rej.body).error.code}`;\r\n          this.showViewportDialog('action', errorMessage, [\r\n            {\r\n              name: 'View projects list',\r\n              function: () => {\r\n                this.openProjectsList();\r\n                if (location.search !== \"\") {\r\n                  history.replaceState({ page: 'Projects list' }, 'Projects list', location.href.replace(location.search, ''));\r\n                }\r\n              }\r\n            }\r\n          ]);\r\n        });\r\n    } else {\r\n      // Delete any invalid search parameter if any.\r\n      if (location.search !== \"\") {\r\n        history.replaceState({ page: 'Projects list' }, 'Projects list', location.href.replace(location.search, ''));\r\n      }\r\n      this.projectsListContainer.style.display = 'block';\r\n      this.showViewportDialog('loader', 'Loading projects');\r\n      // TODO: Limit the number of projects to list\r\n      _api__WEBPACK_IMPORTED_MODULE_0__[\"default\"].listProjectItems(this).then(res => {\r\n        this.createHTMLProjectsList(res);\r\n        this.hideViewportMessage();\r\n      }, rej => {\r\n        this.projectsList.innerHTML = '<p class=\"empty-msg\">There are no projects. Upload one!</p>';\r\n        this.hideViewportMessage();\r\n      });\r\n    }\r\n  }\r\n}\n\n//# sourceURL=webpack:///./src/app.js?");

/***/ }),

/***/ "./src/appTools/addComment.js":
/*!************************************!*\
  !*** ./src/appTools/addComment.js ***!
  \************************************/
/*! exports provided: AddComment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AddComment\", function() { return AddComment; });\n/* harmony import */ var _elementSelection__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./elementSelection */ \"./src/appTools/elementSelection.js\");\n/* harmony import */ var _comment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./../comment */ \"./src/comment.js\");\n\r\n\r\n\r\nclass AddComment extends _elementSelection__WEBPACK_IMPORTED_MODULE_0__[\"ElementSelection\"] {\r\n  constructor(name, toolBtn, workspace) {\r\n    super(name, toolBtn, workspace);\r\n    console.log('Comment element tool enabled.');\r\n    this.boundingBox;\r\n    this.waitingForComment = false;\r\n    this.input = this.workspace.commentForm.elements[\"comment\"];\r\n    this.addComment = this.addComment.bind(this);\r\n    workspace.commentForm.onsubmit = this.addComment;\r\n  }\r\n\r\n\r\n  /**\r\n   * Extends the method of the super class to get the selected element.\r\n   * @param {MouseEvent} e The click event.\r\n   */\r\n  manageSelection(e) {\r\n    if (!this.waitingForComment) {\r\n      super.manageSelection(e);\r\n      if (this.selection !== null) {\r\n        console.log('Add comment to: ', this.selection);\r\n        // Show the form to add the comment.\r\n        this.workspace.mainPanel.addSection('Comment', this.workspace.commentForm);\r\n        this.workspace.mainPanel.open();\r\n        // TODO: Allow to change the commented element by picking another one.\r\n        this.waitingForComment = true;\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  addComment(e) {\r\n    e.preventDefault();\r\n    // If 'activeDrawing' doesnt have a group for comments create it.\r\n    if (this.workspace.activeDrawing.commentsGroup === undefined) {\r\n      this.workspace.activeDrawing.createCommentsGroup();\r\n    }\r\n    const comment = new _comment__WEBPACK_IMPORTED_MODULE_1__[\"Comment\"](this.selection.dataset.id, this.input.value);\r\n    comment.createRepresentation(this.workspace.activeDrawing.commentsGroup, this.selection);\r\n    this.workspace.comments.push(comment);\r\n    console.log(this.workspace.comments);\r\n    this.input.value = '';\r\n    // Hide the comment form.\r\n    this.workspace.mainPanel.removeSection('Comment');\r\n    // TODO: This may be removed because the panel will close itself if empty.\r\n    this.workspace.mainPanel.close();\r\n    this.waitingForComment = false;\r\n    // Workspace method to indicate that there are unsaved changes on comments.\r\n    this.workspace.unsavedCommentsData();\r\n    this.workspace.drawings.forEach(drawing => {\r\n      if (drawing.id !== this.workspace.activeDrawing.id) {\r\n        drawing.commentsChanged = true;\r\n      }\r\n    });\r\n    super.clearSelection();\r\n  }\r\n\r\n\r\n  kill() {\r\n    super.kill();\r\n    console.log('Comment element tool disabled.');\r\n    if (this.waitingForComment) {\r\n      this.workspace.commentForm.style.display = 'none';\r\n      this.input.value = '';\r\n      // Hide the comment form.\r\n      this.workspace.mainPanel.removeSection('Comment');\r\n      // TODO: This may be removed because the panel will close itself if empty.\r\n      this.workspace.mainPanel.close();\r\n    }\r\n    // Remove the tool event listener.\r\n    this.workspace.commentForm.onsubmit = null;\r\n  }\r\n}\n\n//# sourceURL=webpack:///./src/appTools/addComment.js?");

/***/ }),

/***/ "./src/appTools/elementData.js":
/*!*************************************!*\
  !*** ./src/appTools/elementData.js ***!
  \*************************************/
/*! exports provided: ElementData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ElementData\", function() { return ElementData; });\n/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../api */ \"./src/api.js\");\n/* harmony import */ var _elementSelection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./elementSelection */ \"./src/appTools/elementSelection.js\");\n\r\n\r\n\r\nclass ElementData extends _elementSelection__WEBPACK_IMPORTED_MODULE_1__[\"ElementSelection\"] {\r\n  constructor(name, toolBtn, workspace) {\r\n    super(name, toolBtn, workspace);\r\n    console.log('Elements data tool enabled.');\r\n    this.elementsData = workspace.elementsData;\r\n    this.projectsData = workspace.projectsData;\r\n    this.projectIndex = workspace.projectIndex;\r\n    this.currentElementData;\r\n  }\r\n\r\n  /**\r\n   * Extends the method of the super class to get the selected element.\r\n   * @param {MouseEvent} e The click event.\r\n   */\r\n  manageSelection(e) {\r\n    super.manageSelection(e);\r\n    if (this.selection !== null) {\r\n      this.showElementData(this.selection.dataset.category, this.selection.dataset.id);\r\n    } else if (this.currentElementData) {\r\n      this.currentElementData = undefined;\r\n      this.workspace.mainPanel.close();\r\n      this.workspace.mainPanel.removeSection('Properties');\r\n      console.log('Data table cleaned.');\r\n    }\r\n  }\r\n\r\n\r\n  /******************** ELEMENTS ASSOCIATED DATA *******************/\r\n\r\n  /**\r\n   * Shows the data associated with the selected element by fetching it if needed.\r\n   * @param {String} category \r\n   * @param {String} id \r\n   */\r\n  async showElementData(category, id) {\r\n    let success = true;\r\n    if (this.elementsData[category]) {\r\n      this.currentElementData = this.elementsData[category].instances[id];\r\n      console.log(this.currentElementData);\r\n    } else {\r\n      const categoryData = this.projectsData[this.projectIndex].elementsData.find(obj => obj.name.replace('.json', '') === category);\r\n      if (categoryData !== undefined) {\r\n        // TODO: show a loader in the table.\r\n        await _api__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getFileContent(categoryData.id).then(res => {\r\n          this.elementsData[category] = JSON.parse(res.body);\r\n          // TODO: hide the loader in the table.\r\n          this.currentElementData = this.elementsData[category].instances[id];\r\n          console.log(this.currentElementData);\r\n        }, err => {\r\n          // TODO: hide the loader in the table.\r\n          success = false;\r\n          // TODO: show error message.\r\n          console.log(err);\r\n        });\r\n      } else {\r\n        console.log('There is no data for that element.');\r\n      }\r\n    }\r\n    if (success) {\r\n      // Sets the content on the data tables container.\r\n      this.workspace.dataTablesContainer.innerHTML = this.createDataTable(this.currentElementData);\r\n      this.workspace.mainPanel.addSection('Properties', this.workspace.dataTablesContainer);\r\n      this.workspace.mainPanel.open();\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Creates various HTML tables with the data of the provided object.\r\n   * It access two levels of the object, first as titles and second as key value pairs.\r\n   * @param {Object} data \r\n   */\r\n  createDataTable(data) {\r\n    const dataTable = [];\r\n    for (const title in data) {\r\n      dataTable.push('<table class=\"data-table\"><thead><tr><th colspan=\"2\">' + title + '</th></tr></thead>');\r\n      dataTable.push('<tbody>');\r\n      for (const field in data[title]) {\r\n        dataTable.push('<tr>');\r\n        dataTable.push('<th>' + field + '</th>');\r\n        dataTable.push('<td>' + data[title][field] + '</td>');\r\n        dataTable.push('</tr>');\r\n      }\r\n      dataTable.push('</tbody></table>');\r\n    }\r\n    dataTable.push('</table>');\r\n    return dataTable.join('');\r\n  }\r\n\r\n\r\n  kill() {\r\n    super.kill();\r\n    // TODO: Clear the data table.\r\n    if (this.workspace.mainPanel.isOpen) {\r\n      this.workspace.mainPanel.close();\r\n      this.workspace.mainPanel.removeSection('Properties');\r\n    }\r\n    console.log('Elements data tool disabled.');\r\n  }\r\n}\n\n//# sourceURL=webpack:///./src/appTools/elementData.js?");

/***/ }),

/***/ "./src/appTools/elementSelection.js":
/*!******************************************!*\
  !*** ./src/appTools/elementSelection.js ***!
  \******************************************/
/*! exports provided: ElementSelection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ElementSelection\", function() { return ElementSelection; });\n/* harmony import */ var _tool__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tool */ \"./src/appTools/tool.js\");\n\r\n\r\nclass ElementSelection extends _tool__WEBPACK_IMPORTED_MODULE_0__[\"Tool\"] {\r\n  constructor(name, toolBtn, workspace) {\r\n    super(name, toolBtn, workspace);\r\n    this.currentSelection; // TODO: This could be a property of the workspace?\r\n    this.selection; // TODO: Rename as clickedElement ?\r\n    this.manageSelection = this.manageSelection.bind(this);\r\n    workspace.drawingsContainer.addEventListener('click', this.manageSelection);\r\n  }\r\n\r\n\r\n  /********************* SELECTION OF ELEMENTS *********************/\r\n\r\n  /**\r\n   * Manages the selection and deselection of the svg elements.\r\n   * This should be extended to obtain the selected element.\r\n   * @param {MouseEvent} e The click event.\r\n   */\r\n  manageSelection(e) {\r\n    this.selection = e.target.closest('[selectable]');\r\n    if (this.selection !== null) {\r\n      if (this.currentSelection === undefined) {\r\n        this.select(this.selection);\r\n        this.currentSelection = this.selection;\r\n      } else if (this.selection.dataset.id !== this.currentSelection.dataset.id) {\r\n        if (this.workspace.activeDrawing.content.querySelector('[data-id=\"' + this.currentSelection.dataset.id + '\"]')) {\r\n          this.deselect(this.currentSelection);\r\n        }\r\n        this.select(this.selection);\r\n        this.currentSelection = this.selection;\r\n      }\r\n    } else if (this.currentSelection !== undefined) {\r\n      if (this.workspace.activeDrawing.content.querySelector('[data-id=\"' + this.currentSelection.dataset.id + '\"]')) {\r\n        this.deselect(this.currentSelection);\r\n      }\r\n      this.currentSelection = undefined;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Selects the specified element.\r\n   * @param {SVGGElement} element An SVG selectable element.\r\n   */\r\n  select(element) {\r\n    for (let i = 0; i < element.children.length; i++)\r\n      element.children[i].classList.add('selected');\r\n  }\r\n\r\n  /**\r\n   * Deselects the specified element.\r\n   * @param {SVGGElement} element An SVG selectable element.\r\n   */\r\n  deselect(element) {\r\n    for (let i = 0; i < element.children.length; i++)\r\n      element.children[i].classList.remove('selected');\r\n  }\r\n\r\n  /**\r\n   * Removes the selection from all selected elements in the workspace if any.\r\n   */\r\n  clearSelection() {\r\n    if (this.currentSelection) {\r\n      //this.currentSelection.classList.remove('selected');\r\n      this.deselect(this.currentSelection);\r\n      this.currentSelection = undefined;\r\n    }\r\n  }\r\n\r\n\r\n  kill() {\r\n    super.kill();\r\n    this.workspace.drawingsContainer.removeEventListener('click', this.manageSelection);\r\n    this.clearSelection();\r\n  }\r\n}\n\n//# sourceURL=webpack:///./src/appTools/elementSelection.js?");

/***/ }),

/***/ "./src/appTools/tool.js":
/*!******************************!*\
  !*** ./src/appTools/tool.js ***!
  \******************************/
/*! exports provided: Tool */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Tool\", function() { return Tool; });\nclass Tool {\r\n  constructor(name, toolBtn, workspace) {\r\n    this.name = name;\r\n    this.toolBtn = toolBtn;\r\n    this.workspace = workspace;\r\n    this.toolBtn.classList.add('btn-tool-enabled');\r\n  }\r\n\r\n  kill() {\r\n    this.toolBtn.classList.remove('btn-tool-enabled');\r\n  }\r\n}\n\n//# sourceURL=webpack:///./src/appTools/tool.js?");

/***/ }),

/***/ "./src/comment.js":
/*!************************!*\
  !*** ./src/comment.js ***!
  \************************/
/*! exports provided: Comment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Comment\", function() { return Comment; });\n/* harmony import */ var _generics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./generics */ \"./src/generics.js\");\n\r\n\r\nclass Comment {\r\n  constructor(elementId, content) {\r\n    this.elementId = elementId,\r\n      this.content = content,\r\n      this.id = 'c-' + elementId,\r\n      this.representations = []\r\n  }\r\n\r\n  /**\r\n   * Creates an svg representation for the comment on the provided element and\r\n   * adds it to the group of comment representations on the svg drawing.\r\n   * @param {SVGGElement} commentsGroup\r\n   * @param {SVGElement} element \r\n   */\r\n  createRepresentation(commentsGroup, element) {\r\n    const representation = _generics__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createBBox(element, 15, 15);\r\n    // TODO: the style values will come from the app settings file if any.\r\n    representation.setAttribute('style', 'fill:none;stroke:#e22a2a;stroke-width:8px;stroke-dasharray:18;');\r\n    representation.dataset.id = this.id;\r\n    commentsGroup.appendChild(representation);\r\n    this.representations.push(representation);\r\n  }\r\n}\n\n//# sourceURL=webpack:///./src/comment.js?");

/***/ }),

/***/ "./src/drawing.js":
/*!************************!*\
  !*** ./src/drawing.js ***!
  \************************/
/*! exports provided: Drawing */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Drawing\", function() { return Drawing; });\nclass Drawing {\r\n  constructor(name, id) {\r\n    this.name = name;\r\n    this.id = id;\r\n    this.content;\r\n\r\n    this.svgCanvas;\r\n\r\n    this.commentsGroup;\r\n\r\n    this.commentsChanged;\r\n\r\n    //this.zoomValue;\r\n  }\r\n\r\n  setContent(content) {\r\n    this.content = document.createElement('div');\r\n    const domparser = new DOMParser();\r\n    this.svgCanvas = domparser.parseFromString(content, 'image/svg+xml').documentElement;\r\n    this.content.appendChild(this.svgCanvas);\r\n  }\r\n\r\n  createCommentsGroup() {\r\n    this.commentsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\r\n    // group.setAttribute('comments', '');\r\n    this.svgCanvas.appendChild(this.commentsGroup);\r\n  }\r\n\r\n  //zoom() {\r\n\r\n  //}\r\n\r\n}\n\n//# sourceURL=webpack:///./src/drawing.js?");

/***/ }),

/***/ "./src/generics.js":
/*!*************************!*\
  !*** ./src/generics.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (class {\r\n\r\n  /**\r\n  * Read the content of a file.\r\n  * @param {Blob} file \r\n  */\r\n  static readInputFile(file) {\r\n    return new Promise((res, rej) => {\r\n      const reader = new FileReader();\r\n      reader.readAsText(file, \"UTF-8\");\r\n      reader.onload = () => {\r\n        res(reader.result);\r\n      }\r\n      reader.onerror = () => {\r\n        console.log(\"Error reading the file.\");\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n  * Get the URL parameters.\r\n  * Source: https://css-tricks.com/snippets/javascript/get-url-variables/\r\n  * @param  {String} url The URL\r\n  * @return {Object}     The URL parameters\r\n  */\r\n  static getUrlParams(url) {\r\n    const params = {};\r\n    const parser = document.createElement('a');\r\n    parser.href = url;\r\n    const vars = parser.search.substring(1).split('&');\r\n    for (let i = 0; i < vars.length; i++) {\r\n      const pair = vars[i].split('=');\r\n      params[pair[0]] = decodeURIComponent(pair[1]);\r\n    }\r\n    return params;\r\n  }\r\n\r\n  /**\r\n   * Removes all the childs of the HTML element.\r\n   * @param {HTMLElement} node \r\n   */\r\n  static emptyNode(node) {\r\n    while (node.firstChild && node.removeChild(node.firstChild));\r\n  }\r\n\r\n  /**\r\n   * Creates a fillet bounding box around the provided element.\r\n   * @param {SVGElement} element \r\n   * @param {Number} offset Optional, with default 5.\r\n   * @param {Number} fillet Optional, with default 5.\r\n   */\r\n  static createBBox(element, offset = 5, fillet = 5) {\r\n    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\r\n    rect.setAttribute('x', element.getBBox().x - offset);\r\n    rect.setAttribute('y', element.getBBox().y - offset);\r\n    rect.setAttribute('width', element.getBBox().width + offset * 2);\r\n    rect.setAttribute('height', element.getBBox().height + offset * 2);\r\n    rect.setAttribute('rx', fillet);\r\n    rect.setAttribute('ry', fillet);\r\n    return rect;\r\n  }\r\n});\r\n\n\n//# sourceURL=webpack:///./src/generics.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./app */ \"./src/app.js\");\n/* harmony import */ var _generics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./generics */ \"./src/generics.js\");\n/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./api */ \"./src/api.js\");\n\r\n\r\n\r\n\r\n\r\n/****************** THE ONLY INSTANCE OF THE APP *******************/\r\n\r\nconst App = new _app__WEBPACK_IMPORTED_MODULE_0__[\"Application\"]();\r\n\r\n\r\n/******************* VIEW SAMPLE PROJECT OPTION ********************/\r\n\r\nconst sampleProjectBtn = document.getElementById('sampleProjectBtn');\r\n\r\nsampleProjectBtn.onclick = () => {\r\n  document.getElementById('projectsListBtn').onclick = null;\r\n  App.saveBtn.style.visibility = 'hidden';\r\n  App.projectsListBtn.classList.add('locked');\r\n  // TODO: Change the Sign Out button for the Log In button on the side menu.\r\n  App.start('1D4ESY97zKvJoZ1BWeLWYq8GxhQNWsXpg');\r\n}\r\n\r\n\r\n/************************** AUTHENTICATION *************************/\r\n\r\n\r\n// Client ID and API key from the Developer Console\r\nconst CLIENT_ID = '199844453643-0s921ir25l6rrventemkvr5te5aattej.apps.googleusercontent.com';\r\nconst API_KEY = 'AIzaSyDgot_h8p7RzZunGoSDVlKxrpUNN97rPeg';\r\n\r\n// Array of API discovery doc URLs for APIs used by the quickstart\r\nconst DISCOVERY_DOCS = [\"https://www.googleapis.com/discovery/v1/apis/drive/v3/rest\"];\r\n\r\n// Authorization scopes required by the API; multiple scopes can be included, separated by spaces.\r\nconst SCOPES = \"https://www.googleapis.com/auth/drive\";\r\n\r\nconst authorizeButton = document.getElementById('authorizeBtn');\r\nconst signoutButton = document.getElementById('signoutBtn');\r\n\r\n\r\n/**\r\n *  On load, called to load the auth2 library and API client library.\r\n */\r\n(function () {\r\n  const script = document.createElement('script');\r\n  script.type = \"text/javascript\";\r\n  script.defer = true;\r\n  script.onload = () => handleClientLoad();\r\n  script.src = 'https://apis.google.com/js/api.js';\r\n  document.querySelector('body').appendChild(script);\r\n})();\r\n\r\n\r\nfunction handleClientLoad() {\r\n  gapi.load('client:auth2', initClient);\r\n}\r\n\r\n\r\n/**\r\n *  Initializes the API client library and sets up sign-in state listeners.\r\n */\r\nfunction initClient() {\r\n  gapi.client.init({\r\n    apiKey: API_KEY,\r\n    clientId: CLIENT_ID,\r\n    discoveryDocs: DISCOVERY_DOCS,\r\n    scope: SCOPES\r\n  }).then(function () {\r\n    // Listen for sign-in state changes.\r\n    gapi.auth2.getAuthInstance().isSignedIn.listen(updateSigninStatus);\r\n\r\n    // Handle the initial sign-in state.\r\n    updateSigninStatus(gapi.auth2.getAuthInstance().isSignedIn.get());\r\n    authorizeButton.onclick = handleAuthClick;\r\n    signoutButton.onclick = handleSignoutClick;\r\n  }, function (error) {\r\n    console.log(JSON.stringify(error, null, 2));\r\n  });\r\n}\r\n\r\n\r\n/**\r\n *  Called when the signed in status changes, to update the UI\r\n *  appropriately. After a sign-in, the API is called.\r\n */\r\nfunction updateSigninStatus(isSignedIn) {\r\n  if (isSignedIn) {\r\n    console.log('Authorized.');\r\n    // Get the URL params.\r\n    const projectId = _generics__WEBPACK_IMPORTED_MODULE_1__[\"default\"].getUrlParams(window.location.href).id;\r\n    // Hide the login dialog in case it was visible.\r\n    if (App.modalDialogContent.firstElementChild) {\r\n      App.closeModalDialog();\r\n    }\r\n    // Manage the logged user personal info.\r\n    App.setUserInfo();\r\n    // If a project id is provided to start() method the app will start from the project view.\r\n    App.start(projectId);\r\n  } else {\r\n    console.log('Not authorized');\r\n    showLoginDialog();\r\n  }\r\n}\r\n\r\n\r\n/**\r\n *  Sign in the user upon button click.\r\n */\r\nfunction handleAuthClick(event) {\r\n  gapi.auth2.getAuthInstance().signIn();\r\n}\r\n\r\n\r\n/**\r\n *  Sign out the user upon button click.\r\n */\r\nfunction handleSignoutClick(event) {\r\n  gapi.auth2.getAuthInstance().signOut();\r\n}\r\n\r\n\r\n/************************** LOGIN DIALOG ***************************/\r\n\r\n\r\nconst authorizeDialog = document.getElementById('authorizeDialog');\r\n\r\n/**\r\n * Shows the login dialog and hides and clears anything else.\r\n */\r\nfunction showLoginDialog() {\r\n  App.showModalDialog(authorizeDialog);\r\n  // Hide anything else.\r\n  document.querySelector('header').style.display = 'none';\r\n  document.querySelector('main').style.display = 'none';\r\n  App.projectsListContainer.style.display = 'none';\r\n  // TODO: Delete the contents of the global objects if any.\r\n  // appData.clear();\r\n  // currentProject.clear();\r\n  // lastUploadedProject.clear();\r\n  _generics__WEBPACK_IMPORTED_MODULE_1__[\"default\"].emptyNode(App.projectsList);\r\n  history.replaceState({ page: 'Sign in dialog' }, 'Sign in dialog', location.href.replace(location.search, ''));\r\n}\r\n\r\n\r\n/********************** DRAWINGS BUTTONS LIST **********************/\r\n/*\r\n * A single event listener in the container of the drawings buttons manages the clicked drawing.\r\n */\r\n\r\nlet currentDrawingBtn;\r\n\r\nApp.drawingsBtns.querySelector('.dropdown-content').addEventListener('click', async function (e) {\r\n  if (currentDrawingBtn) {\r\n    currentDrawingBtn.classList.remove('active');\r\n  }\r\n  currentDrawingBtn = e.target;\r\n  const drawingId = currentDrawingBtn.dataset.id;\r\n  // Set the name of the drawing on the dropdown button.\r\n  // TODO: Do this only if it was successful.\r\n  App.drawingsBtns.children[0].innerText = currentDrawingBtn.innerText;\r\n  currentDrawingBtn.classList.add('active');\r\n\r\n  // Get the corresponding drawing object.\r\n  const requestedDrawing = App.workspace.drawings.find(d => d.id === drawingId);\r\n\r\n  // Load the drawings styles if it is the first time.\r\n  // TODO: If this is required always the first time maybe do it in the Workspace constructor.\r\n  // TODO: If this finally extracted then the function wont need to be async anymore.\r\n  if (App.workspace.drawingsStylesTag === undefined) {\r\n    const stylesRes = await _api__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getFileContent(App.workspace.drawingsStylesId);\r\n    const styleTag = document.createElement('style');\r\n    styleTag.innerText = stylesRes.body;\r\n    document.head.appendChild(styleTag);\r\n    App.workspace.drawingsStylesTag = styleTag;\r\n  }\r\n\r\n  // Check if the requested drawing has already the content.\r\n  if (requestedDrawing.content !== undefined) {\r\n    App.workspace.setDrawing(requestedDrawing);\r\n  } else {\r\n    App.showViewportDialog('loader', 'Loading drawing');\r\n    _api__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getFileContent(drawingId).then(res => {\r\n      requestedDrawing.setContent(res.body);\r\n      App.workspace.setDrawing(requestedDrawing);\r\n      App.hideViewportMessage();\r\n      console.log('Drawing fetched.');\r\n    }, err => {\r\n      console.log(err);\r\n    });\r\n  }\r\n});\r\n\r\n\r\n/********************* DROPDOWNS FUNCTIONALITY *********************/\r\n\r\nconst dropdowns = document.getElementsByClassName('dropdown-container');\r\n\r\nfor (let i = 0; i < dropdowns.length; i++) {\r\n  dropdowns[i].children[0].addEventListener('click', () => {\r\n    dropdowns[i].classList.toggle('open');\r\n  });\r\n  dropdowns[i].addEventListener('mouseleave', e => {\r\n    e.currentTarget.classList.remove('open');\r\n  });\r\n}\r\n\r\n\r\n/************************ SIDE NAVE MENU ***************************/\r\n\r\nconst sideNavToggle = document.getElementById('sideNavToggle');\r\n\r\nsideNavToggle.addEventListener('click', () => {\r\n  document.getElementById('sideNavContainer').classList.toggle('active');\r\n  sideNavToggle.classList.toggle('active');\r\n});\r\n\r\n\r\n/************************* CONTEXT MENU ****************************/\r\n\r\nconst contextMenu = document.getElementById('contextMenu');\r\nlet menuVisible = false;\r\n\r\nfunction toggleMenu(command) {\r\n  contextMenu.style.display = command === \"show\" ? \"block\" : \"none\";\r\n  menuVisible = !menuVisible;\r\n}\r\n\r\nfunction setPosition({ top, left }) {\r\n  contextMenu.style.left = `${left}px`;\r\n  contextMenu.style.top = `${top}px`;\r\n  toggleMenu(\"show\");\r\n}\r\n\r\nwindow.addEventListener(\"click\", () => {\r\n  if (menuVisible) toggleMenu(\"hide\");\r\n});\r\n\r\nwindow.addEventListener(\"contextmenu\", e => {\r\n  e.preventDefault();\r\n  // Context menu for a project item.\r\n  if (e.target.closest('[data-proj-id]')) {\r\n    // Clean previous content of the context menu.\r\n    contextMenu.querySelector('ul').childNodes.forEach(btn => btn.onclick = null);\r\n    _generics__WEBPACK_IMPORTED_MODULE_1__[\"default\"].emptyNode(contextMenu.querySelector('ul'));\r\n    // Get the project item.\r\n    const projectItem = e.target.closest('[data-proj-id]');\r\n    // Get the index of the project in the projectsData.\r\n    const projIndex = App.projectsData.findIndex(proj => proj.id === projectItem.dataset.projId);\r\n    // Create the delete button.\r\n    const deleteBtn = document.createElement('li');\r\n    deleteBtn.innerText = 'Delete';\r\n    deleteBtn.onclick = () => {\r\n      App.showViewportDialog('action', `Are you sure you want to delete the ${projectItem.dataset.name} project?`, [\r\n        {\r\n          name: 'Delete',\r\n          function: () => {\r\n            App.showViewportDialog('loader', `Deleting ${projectItem.dataset.name} project.`);\r\n            _api__WEBPACK_IMPORTED_MODULE_2__[\"default\"].deleteFile(projectItem.dataset.projId).then(res => {\r\n              projectItem.remove();\r\n              App.projectsData.splice(projIndex, 1);\r\n              // TODO check also if it is in the value of currentProject or lastUploadedProject and delete it as well\r\n              App.hideViewportMessage();\r\n              App.showMessage('success', 'Project deleted successfully');\r\n            });\r\n          }\r\n        },\r\n        {\r\n          name: 'Cancel',\r\n          function: () => {\r\n            App.hideViewportMessage();\r\n          }\r\n        }\r\n      ]);\r\n    };\r\n    contextMenu.querySelector('ul').appendChild(deleteBtn);\r\n    // Create the share button.\r\n    const shareBtn = document.createElement('li');\r\n    shareBtn.innerText = 'Share project';\r\n    shareBtn.onclick = () => {\r\n      App.shareProjectDialog.openDialog(App.projectsData[projIndex]);\r\n      App.showModalDialog(App.shareProjectDialog.htmlContainer);\r\n      App.modalDialogContainer.classList.add('grayTranslucent');\r\n    }\r\n    contextMenu.querySelector('ul').appendChild(shareBtn);\r\n    const origin = {\r\n      left: e.pageX,\r\n      top: e.pageY\r\n    };\r\n    setPosition(origin);\r\n  } else {\r\n    if (menuVisible) toggleMenu(\"hide\");\r\n  }\r\n});\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/mainPanel.js":
/*!**************************!*\
  !*** ./src/mainPanel.js ***!
  \**************************/
/*! exports provided: MainPanel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MainPanel\", function() { return MainPanel; });\nclass MainPanel {\r\n  constructor(panel, panelsStorage) {\r\n    this.panel = panel;\r\n    this.panelsStorage = panelsStorage;\r\n    this.panelHeader = this.panel.querySelector('.panel-header');\r\n    this.panelBody = this.panel.querySelector('.panel-body');\r\n    this.panelFooter = this.panel.querySelector('.panel-footer');\r\n    this.activeSection;\r\n    this.isOpen;\r\n    this.sections = [];\r\n    this.setActive = this.setActive.bind(this);\r\n    this.panelHeader.onclick = e => {\r\n      if (e.target.closest('[data-btn]') || !button.classList.contains('active'))\r\n        this.setActive(e.target.closest('[data-btn]'));\r\n    };\r\n  }\r\n\r\n  // TODO: Make the panel close automatically if empty.\r\n  open() {\r\n    this.panel.classList.add('open');\r\n    this.isOpen = true;\r\n  }\r\n\r\n  close() {\r\n    this.panel.classList.remove('open');\r\n    this.isOpen = false;\r\n  }\r\n\r\n  /**\r\n   * Docks the panel on the specified side.\r\n   * @param {String} side Options: right or bottom.\r\n   */\r\n  dockTo(side) {\r\n    if (side === 'right') {\r\n      this.panel.classList.remove('bottom');\r\n      this.panel.classList.add('right');\r\n    } else if (side === 'bottom') {\r\n      this.panel.classList.remove('right');\r\n      this.panel.classList.add('bottom');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets a section as active.\r\n   * @param {HTMLElement} button The button container that correspons to the section to activate.\r\n   */\r\n  setActive(button) {\r\n    if (this.activeSection) {\r\n      this.activeSection.button.classList.remove('active');\r\n      this.activeSection.body.classList.add('hidden');\r\n    }\r\n    // This means that sections should have unique names.\r\n    this.activeSection = this.sections.find(s => s.name === button.innerText);\r\n    this.activeSection.button.classList.add('active');\r\n    this.activeSection.body.classList.remove('hidden');\r\n  }\r\n\r\n  /**\r\n   * Adds a new section to the panel contents and sets it as active.\r\n   * If a section with this name already exists then it is only activated.\r\n   * @param {String} name\r\n   * @param {HMLTElement} body\r\n   */\r\n  addSection(name, body) {\r\n    let section = this.sections.find(s => s.name === name);\r\n    if (section === undefined) {\r\n      // The section button.\r\n      const button = document.createElement('span');\r\n      button.innerText = name;\r\n      button.dataset.btn = '';\r\n      this.panelHeader.appendChild(button);\r\n      this.panelBody.appendChild(body);\r\n      section = { name, button, body };\r\n      // Added to sections array.\r\n      this.sections.push(section);\r\n    }\r\n    this.setActive(section.button);\r\n    console.log('Panel sections:', this.sections);\r\n  }\r\n\r\n  /**\r\n   * Removes a section form the panel contents.\r\n   * @param {String} name \r\n   */\r\n  removeSection(name) {\r\n    const sectionIndex = this.sections.findIndex(s => s.name === name);\r\n    const section = this.sections.splice(sectionIndex, 1)[0];\r\n    section.button.remove();\r\n    this.panelsStorage.appendChild(section.body);\r\n    console.log('Panel sections:', this.sections);\r\n  }\r\n\r\n  kill() {\r\n    //Remove event liseners\r\n    this.panelHeader.onclick = null;\r\n  }\r\n}\n\n//# sourceURL=webpack:///./src/mainPanel.js?");

/***/ }),

/***/ "./src/projectData.js":
/*!****************************!*\
  !*** ./src/projectData.js ***!
  \****************************/
/*! exports provided: ProjectData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ProjectData\", function() { return ProjectData; });\n// TODO This is not being used.\r\n\r\nclass ProjectData {\r\n  constructor() {\r\n    this.id = undefined;\r\n    this.name = undefined;\r\n    this.index = undefined; // Index in the appData.projectsData array\r\n    this.drawings = {};\r\n    this.elementsData = {};\r\n    this.shared;\r\n    this.permissions = []; // Array of objects with the permissions of users over the project folder.\r\n    this.thumbId;\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack:///./src/projectData.js?");

/***/ }),

/***/ "./src/shareProject.js":
/*!*****************************!*\
  !*** ./src/shareProject.js ***!
  \*****************************/
/*! exports provided: ShareProject */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ShareProject\", function() { return ShareProject; });\n/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api */ \"./src/api.js\");\n/* harmony import */ var _generics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./generics */ \"./src/generics.js\");\n\r\n\r\n\r\nclass ShareProject {\r\n  constructor(shareProjectContainer, App) {\r\n    this.htmlContainer = shareProjectContainer; // This is used in the context menu to pass it to the showModalDialog()\r\n    this.shareForm = shareProjectContainer.querySelector('.share-form');\r\n    this.confirmChangesBtns = shareProjectContainer.querySelector('.confirm-changes-btns');\r\n    this.saveChangesBtn = shareProjectContainer.querySelector('.save-changes-btn');\r\n    this.cancelChangesBtn = shareProjectContainer.querySelector('.cancel-changes-btn');\r\n    this.waitingAnimation = shareProjectContainer.querySelector('.loader-container');\r\n    this.currentUsersContent = shareProjectContainer.querySelector('.current-users');\r\n    this.currentUsersTable = shareProjectContainer.querySelector('.current-users tbody');\r\n    this.pendingUsersContent = shareProjectContainer.querySelector('.pending-users');\r\n    this.pendingUsersToAddTable = shareProjectContainer.querySelector('.pending-users tbody');\r\n\r\n    // The App is needed to access some of its methods.\r\n    this.app = App;\r\n\r\n    // The App projectsList is needed to get the HTML item of the project to share.\r\n    this.projectsList = App.projectsList;\r\n\r\n    this.projectData;\r\n    // Reference to the project HTML item element in the list.\r\n    this.projectItem;\r\n\r\n    // Array of permission ids (str) pending to delete for the current project.\r\n    this.pendingToRemove = [];\r\n\r\n    // Array of emails to share with.\r\n    this.pendingToAdd = [];\r\n\r\n    this.currentUsersTable.addEventListener('click', e => {\r\n      if (e.target.closest('[data-action]')) {\r\n        const actionBtn = e.target.closest('[data-action]');\r\n        if (actionBtn.dataset.action === 'stage') {\r\n          this.stageMemberToRemove(actionBtn.parentElement);\r\n        } else { // e.target.dataset.action === 'unstage'\r\n          this.unstageMemberToRemove(actionBtn.parentElement);\r\n        }\r\n      }\r\n    });\r\n\r\n    this.pendingUsersToAddTable.addEventListener('click', e => {\r\n      if (e.target.closest('[data-action]')) {\r\n        this.unstageMemberToAdd(e.target.closest('[data-action]').parentElement);\r\n      }\r\n    });\r\n\r\n    this.saveChanges = this.saveChanges.bind(this);\r\n\r\n    this.stageMemberToAdd = this.stageMemberToAdd.bind(this);\r\n    this.shareForm.onsubmit = this.stageMemberToAdd;\r\n  }\r\n\r\n\r\n  /**\r\n   * When the modal dialog that contains this is open this method should be called.\r\n   * @param {Object} projectData \r\n   */\r\n  openDialog(projectData) {\r\n    // Reset to an initial state. Maybe it is better to do this when the previous dialog is closed?\r\n    this.pendingToRemove = [];\r\n    _generics__WEBPACK_IMPORTED_MODULE_1__[\"default\"].emptyNode(this.currentUsersTable);\r\n    this.pendingToAdd = [];\r\n    _generics__WEBPACK_IMPORTED_MODULE_1__[\"default\"].emptyNode(this.pendingUsersToAddTable);\r\n    this.pendingUsersContent.classList.add('hidden');\r\n    for (let i = 0; i < this.confirmChangesBtns.children.length; i++) {\r\n      this.confirmChangesBtns.children[i].classList.add('disabled');\r\n    }\r\n    // Disable the manage changes buttons.\r\n    this.saveChangesBtn.onclick = null;\r\n    this.cancelChangesBtn.onclick = null;\r\n    // Get the project info.\r\n    this.projectData = projectData;\r\n    this.projectItem = this.projectsList.querySelector('button[data-proj-id=\"' + projectData.id + '\"]');\r\n    // Create list of users if any.\r\n    if (projectData.shared) {\r\n      const users = [];\r\n      projectData.permissions.forEach(user => {\r\n        if (user.role !== 'owner') {\r\n          users.push(`\r\n            <tr data-permission=\"${user.id}\">\r\n              <td class=\"user-data\"><span>${user.displayName}</span><span>${user.emailAddress}</span></td>\r\n              <td class=\"action-btn\" data-action=\"stage\"><svg><use href=\"#crossIcon\"></use></svg></td>\r\n            </tr>`);\r\n        }\r\n      });\r\n      this.currentUsersTable.innerHTML = users.join('');\r\n      // Show the table because it could be hidden from the previous time.\r\n      this.currentUsersContent.classList.remove('empty');\r\n    } else {\r\n      this.currentUsersContent.classList.add('empty');\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Add a member email to the waiting list to be added as member.\r\n   * @param {Event} e The submit event of the form to stage members to add.\r\n   */\r\n  stageMemberToAdd(e) {\r\n    e.preventDefault();\r\n    const emailAddress = e.target.elements['email'].value;\r\n    if (emailAddress !== '' && !this.pendingToAdd.includes(emailAddress) && this.projectData.permissions.find(p => p.emailAddress === emailAddress) === undefined) {\r\n      this.pendingToAdd.push(emailAddress);\r\n      this.pendingUsersToAddTable.insertAdjacentHTML('beforeend', `\r\n        <tr data-email=\"${emailAddress}\">\r\n          <td class=\"user-data\"><span>${emailAddress}</span></td>\r\n          <td class=\"action-btn\" data-action=\"stage\"><svg><use href=\"#crossIcon\"></use></svg></td>\r\n        </tr>`);\r\n      e.target.elements['email'].value = '';\r\n      // Actions when the first email is added to the table.\r\n      if (this.pendingToAdd.length === 1) {\r\n        this.pendingUsersContent.classList.remove('hidden');\r\n        // If this makes that there are changes to save enable the buttons.\r\n        if (this.pendingToRemove.length === 0) {\r\n          for (let i = 0; i < this.confirmChangesBtns.children.length; i++) {\r\n            this.confirmChangesBtns.children[i].classList.remove('disabled');\r\n          }\r\n          // Enable the manage changes buttons.\r\n          this.saveChangesBtn.onclick = this.saveChanges;\r\n          this.cancelChangesBtn.onclick = this.app.closeModalDialog;\r\n        }\r\n      }\r\n    } else {\r\n      console.log('Not valid input.');\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Removes from the staged state a member pending to be added.\r\n   * @param {HTMLTableRowElement} element Table row HTML element with the data of the member to unstage. It should have a data attr with the email.\r\n   */\r\n  unstageMemberToAdd(element) {\r\n    const itemIndex = this.pendingToAdd.indexOf(element.dataset.email);\r\n    this.pendingToAdd.splice(itemIndex, 1);\r\n    element.remove();\r\n    // Actions when the table has become empty.\r\n    if (this.pendingToAdd.length === 0) {\r\n      this.pendingUsersContent.classList.add('hidden');\r\n      if (this.pendingToRemove.length === 0) {\r\n        for (let i = 0; i < this.confirmChangesBtns.children.length; i++) {\r\n          this.confirmChangesBtns.children[i].classList.add('disabled');\r\n        }\r\n        // Disable the manage changes buttons.\r\n        this.saveChangesBtn.onclick = null;\r\n        this.cancelChangesBtn.onclick = null;\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Adds a current member to the waiting list to be removed as member.\r\n   * @param {HTMLTableRowElement} element Table row HTML element with the data of the member to delete. It should have a data attr with the permission id.\r\n   */\r\n  stageMemberToRemove(element) {\r\n    this.pendingToRemove.push(element.dataset.permission);\r\n    // Set the row element as pending to delete.\r\n    element.classList.add('to-delete');\r\n    // Change the row button action and icon.\r\n    const actionBtn = element.querySelector('.action-btn');\r\n    actionBtn.innerHTML = '<svg><use href=\"#reloadIcon\"></use></svg>';\r\n    actionBtn.dataset.action = \"unstage\";\r\n    // If this makes that there are changes to save enable the 'confirm changes' buttons.\r\n    if (this.pendingToAdd.length === 0 && this.pendingToRemove.length === 1) {\r\n      for (let i = 0; i < this.confirmChangesBtns.children.length; i++) {\r\n        this.confirmChangesBtns.children[i].classList.remove('disabled');\r\n      }\r\n      // Enable the manage changes buttons.\r\n      this.saveChangesBtn.onclick = this.saveChanges;\r\n      this.cancelChangesBtn.onclick = this.app.closeModalDialog;\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Removes from the staged state a member pending to be removed.\r\n   * @param {HTMLTableRowElement} element Table row HTML element with the data of the member to delete. It should have a data attr with the permission id.\r\n   */\r\n  unstageMemberToRemove(element) {\r\n    // Remove the permission id from the array.\r\n    const index = this.pendingToRemove.indexOf(element.dataset.permission);\r\n    this.pendingToRemove.splice(index, 1);\r\n    // Remove its to-delete class.\r\n    element.classList.remove('to-delete');\r\n    // Change the row button action and icon.\r\n    const actionBtn = element.querySelector('.action-btn');\r\n    actionBtn.innerHTML = '<svg><use href=\"#crossIcon\"></use></svg>';\r\n    actionBtn.dataset.action = \"stage\";\r\n    // If this makes that there are no changes then disable the 'confirm changes' buttons.\r\n    if (this.pendingToRemove.length === 0 && this.pendingToAdd.length === 0) {\r\n      for (let i = 0; i < this.confirmChangesBtns.children.length; i++) {\r\n        this.confirmChangesBtns.children[i].classList.add('disabled');\r\n      }\r\n      // Disable the manage changes buttons.\r\n      this.saveChangesBtn.onclick = null;\r\n      this.cancelChangesBtn.onclick = null;\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Removes from the staged state all current members that were pending to be removed.\r\n   */\r\n  // TODO: Change to a reset method that cleans any staged member?\r\n  // unstageAllMembersToRemove() {\r\n  //   // Remove the pending to delte state from the row elements.\r\n  //   this.pendingToRemove.forEach(element => {\r\n  //     element.classList.remove('to-delete');\r\n  //   });\r\n  //   // Clear the staged users.\r\n  //   this.pendingToRemove = [];\r\n  //   // If this makes that there are no changes then disable the 'confirm changes' buttons.\r\n  //   if (this.pendingToAdd.length === 0) {\r\n  //     for (let i = 0; i < this.confirmChangesBtns.children.length; i++) {\r\n  //       this.confirmChangesBtns.children[i].classList.add('disabled');\r\n  //     }\r\n  //     // TODO to disable the btns add the event listener or change a bool\r\n  //   }\r\n  // }\r\n\r\n\r\n  /**\r\n   * Adds all members that were in the pendingToAdd array to the team.\r\n   */\r\n  addStagedMembers() {\r\n    const addMembersPromises = [];\r\n    // Delay is required because GD API doesnt allow to create several permissions at the same time.\r\n    const delay = 600;\r\n    this.pendingToAdd.forEach((email, i) => {\r\n      addMembersPromises.push(_api__WEBPACK_IMPORTED_MODULE_0__[\"default\"].shareFile(this.projectData.id, email, delay * i));\r\n    });\r\n    return Promise.all(addMembersPromises);\r\n  }\r\n\r\n\r\n  /**\r\n   * Removes all current members that were in the pendingToRemove array from the team.\r\n   */\r\n  removeStagedMembers() {\r\n    const removeMembersPromises = [];\r\n    this.pendingToRemove.forEach(permissionId => {\r\n      removeMembersPromises.push(_api__WEBPACK_IMPORTED_MODULE_0__[\"default\"].stopSharingFile(this.projectData.id, permissionId));\r\n    });\r\n    return Promise.all(removeMembersPromises);\r\n  }\r\n\r\n\r\n  /**\r\n   * Save all the changes of addition and removal of members.\r\n   */\r\n  async saveChanges() {\r\n    this.waitingAnimation.classList.remove('hidden');\r\n    let additionSuccess = true;\r\n    let removalSuccess = true;\r\n    // Removal process.\r\n    if (this.pendingToRemove.length > 0) {\r\n      await this.removeStagedMembers().then(resArr => {\r\n        // Remove the permissionIds also from the corresponding projectsData object.\r\n        this.pendingToRemove.forEach(permissionId => {\r\n          const index = this.projectData.permissions.findIndex(permission => permission.id === permissionId);\r\n          this.projectData.permissions.splice(index, 1);\r\n        });\r\n      }, rej => {\r\n        console.log(rej);\r\n        removalSuccess = false;\r\n      });\r\n    }\r\n    // Addition process.\r\n    if (this.pendingToAdd.length > 0) {\r\n      await this.addStagedMembers().then(resArr => {\r\n        // 'resArr' is an array with all the resolved promises.\r\n        resArr.forEach((res, i) => {\r\n          this.projectData.permissions.push({\r\n            kind: res.result.kind,\r\n            id: res.result.id,\r\n            type: res.result.type,\r\n            emailAddress: this.pendingToAdd[i],\r\n            role: res.result.role,\r\n            displayName: 'User name will be available next time the app is launched.'\r\n          });\r\n        });\r\n      }, rej => {\r\n        console.log(rej);\r\n        additionSuccess = false;\r\n      });\r\n    }\r\n    // Actions depending on the success or failure.\r\n    if (additionSuccess && removalSuccess) {\r\n      if (this.projectData.permissions.length === 1) { // 1 because there is always at least the owner.\r\n        this.projectData.shared = false;\r\n        if (this.projectItem.querySelector('.sharedIcon')) {\r\n          this.projectItem.querySelector('.sharedIcon').remove();\r\n        }\r\n      } else {\r\n        this.projectData.shared = true;\r\n        if (!this.projectItem.querySelector('.sharedIcon')) {\r\n          this.projectItem.insertAdjacentHTML('afterbegin', '<img class=\"sharedIcon\" src=\"src/assets/icons/shareIcon.svg\">');\r\n        }\r\n      }\r\n      this.app.showMessage('success', 'Project members updated successfully.', 5000);\r\n    } else {\r\n      this.app.showMessage('error', 'Something went wrong, member changes could no be saved.');\r\n    }\r\n    this.waitingAnimation.classList.add('hidden');\r\n    this.app.closeModalDialog();\r\n  }\r\n}\n\n//# sourceURL=webpack:///./src/shareProject.js?");

/***/ }),

/***/ "./src/workspace.js":
/*!**************************!*\
  !*** ./src/workspace.js ***!
  \**************************/
/*! exports provided: Workspace */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Workspace\", function() { return Workspace; });\n/* harmony import */ var _generics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./generics */ \"./src/generics.js\");\n/* harmony import */ var _comment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./comment */ \"./src/comment.js\");\n/* harmony import */ var _mainPanel__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mainPanel */ \"./src/mainPanel.js\");\n\r\n\r\n\r\n\r\nclass Workspace {\r\n  constructor(projectData, App) {\r\n    this.projectName = projectData.name;\r\n    this.projectId = projectData.id;\r\n    this.projectIndex = App.projectsData.findIndex(obj => obj.name === projectData.name);\r\n    if (projectData.id === App.lastUploadedProject.id) {\r\n      this.drawings = App.lastUploadedProject.drawings;\r\n      //this.drawingsStylesId = App.lastUploadedProject.drawingsStylesId;\r\n      this.elementsData = App.lastUploadedProject.elementsData;\r\n    } else {\r\n      // Store the content of the drawings as entries name:'content'\r\n      this.drawings = projectData.drawings;\r\n      this.drawingsStylesId = projectData.drawingsStylesId;\r\n      // TODO: Elements data could be changed to a similar system like the drawing objects.\r\n      this.elementsData = {};\r\n    }\r\n    this.activeTool;\r\n    // this.toolSettings;\r\n    this.appendedDrawingsIds = [];\r\n    this.activeDrawing; // Drawing object instance.\r\n    // Set title of the project in the button to list the projects.\r\n    App.projectsListBtn.innerHTML = '<span>' + projectData.name + '</span>';\r\n    this.drawingsBtns = App.drawingsBtns;\r\n    this.drawingsContainer = App.drawingsContainer;\r\n    this.drawingsStylesTag;\r\n    this.saveBtn = App.saveBtn;\r\n    this.createDrawingsBtns(this.drawings);\r\n    // Show drawings and tools buttons.\r\n    this.drawingsBtns.children[0].innerText = 'Pick a drawing';\r\n    this.drawingsBtns.style.display = 'unset';\r\n    App.toolbarsContainer.style.display = 'flex';\r\n    this.projectsData = App.projectsData;\r\n    this.commentForm = document.getElementById('commentForm');\r\n    this.dataTablesContainer = document.getElementById('dataTablesContainer');\r\n    this.commentsChangesUnsaved;\r\n    if (projectData.commentsFileId) {\r\n      this.commentsFileId = projectData.commentsFileId;\r\n    }\r\n    this.comments = [];\r\n    if (projectData.comments) {\r\n      // TODO: Create the comment objects each time a workspace is created or before on the AppData.projectsData object?\r\n      projectData.comments.forEach(comment => this.comments.push(new _comment__WEBPACK_IMPORTED_MODULE_1__[\"Comment\"](comment.elementId, comment.content)));\r\n      this.drawings.forEach(drawing => drawing.commentsChanged = true);\r\n    }\r\n    this.mainPanel = new _mainPanel__WEBPACK_IMPORTED_MODULE_2__[\"MainPanel\"](App.mainPanel, App.panelsStorage);\r\n  }\r\n\r\n  // TODO: Set a default 'activeDrawing' with the 'elementsData' tool active by default? this.activeTool = new ElementsData('elementsDataTool', this);\r\n\r\n\r\n  /*********************** TOOLS MANAGEMENT ************************/\r\n\r\n  /**\r\n   * Sets the selected tool as active and turns off the previous one if still active.\r\n   * @param {Event} e\r\n   * @param {Tool} Tool \r\n   * @param {String} name \r\n   */\r\n  manageTools(e, Tool, name) {\r\n    if (this.activeDrawing === undefined) {\r\n      // TODO: Show a message saying that a drawing must be active.\r\n      console.log('A drawing must be active.');\r\n      return;\r\n    }\r\n    if (this.activeTool === undefined) {\r\n      this.activeTool = new Tool(name, e.currentTarget, this);\r\n    } else if (this.activeTool.name !== name) {\r\n      this.activeTool.kill();\r\n      this.activeTool = new Tool(name, e.currentTarget, this);\r\n    } else if (this.activeTool.name === name) {\r\n      this.activeTool.kill();\r\n      this.activeTool = undefined;\r\n    }\r\n  }\r\n\r\n\r\n  unsavedCommentsData() {\r\n    this.commentsChangesUnsaved = true;\r\n    this.saveBtn.classList.remove('disabled');\r\n    this.saveBtn.classList.add('enabled');\r\n  }\r\n\r\n\r\n  /********************** DRAWINGS MANAGEMENT **********************/\r\n\r\n  /**\r\n   * Manages the drawings visibility. The provided drawing object\r\n   * should have the 'content' property already with value.\r\n   * @param {Object} drawing \r\n   */\r\n  setDrawing(drawing) {\r\n    // If there is a previous visible drawing hide it.\r\n    if (this.activeDrawing && this.activeDrawing.name !== drawing.name) {\r\n      // If in the drawing to be hided there is a selection remove it.\r\n      if (this.activeTool && this.activeTool.currentSelection && this.activeDrawing.content.querySelector('[data-id=\"' + this.activeTool.currentSelection.dataset.id + '\"]')) {\r\n        this.activeTool.deselect(this.activeTool.currentSelection);\r\n      }\r\n      this.activeDrawing.content.style.display = 'none';\r\n    } else if (this.activeDrawing && this.activeDrawing.name === drawing.name) {\r\n      return;\r\n    }\r\n\r\n    // Make it not visible until the end of the process. Use visibility\r\n    // because some browsers like Chrome cannot draw new svg elements if\r\n    // the canvas has 'display:none'.\r\n    drawing.content.style.visibility = 'hidden';\r\n\r\n    // If it is not in the DOM already append it.\r\n    // If it is already in the DOM then remove the 'display:none'.\r\n    if (!this.appendedDrawingsIds.includes(drawing.id)) {\r\n      this.appendedDrawingsIds.push(drawing.id);\r\n      this.drawingsContainer.append(drawing.content);\r\n    } else {\r\n      drawing.content.style.display = 'unset';\r\n    }\r\n\r\n    // If the value of commentsChanged is undefined then there are still\r\n    // no comments in the project. If it is false then there are no changes.\r\n    if (drawing.commentsChanged) {\r\n      // Look for elements in the drawing that should have comment representation.\r\n      // If still there is no comments group yet check the drawing, otherwise check\r\n      // in the comments group. This way the comments group is added only if needed.\r\n      if (drawing.commentsGroup === undefined) {\r\n        let groupCreated = false;\r\n        this.comments.forEach(comment => {\r\n          if (drawing.content.querySelector('[data-id=\"' + comment.elementId + '\"]') !== null) {\r\n            // Only if at least one element is found the comments group is created.\r\n            if (!groupCreated) {\r\n              drawing.createCommentsGroup();\r\n              // TODO: Set visibility of the group.\r\n              groupCreated = true;\r\n            }\r\n            const element = drawing.content.querySelector('[data-id=\"' + comment.elementId + '\"]');\r\n            comment.createRepresentation(drawing.commentsGroup, element);\r\n          }\r\n        });\r\n      } else {\r\n        // Look for in the comments group, and add the missing ones.\r\n        // Only if the element is in the drawing and it doesnt have representation.\r\n        this.comments.forEach(comment => {\r\n          if (drawing.content.querySelector('[data-id=\"' + comment.elementId + '\"]') !== null && drawing.commentsGroup.querySelector('[data-id=\"' + comment.id + '\"]') === null) {\r\n            const element = drawing.content.querySelector('[data-id=\"' + comment.elementId + '\"]');\r\n            comment.createRepresentation(drawing.commentsGroup, element);\r\n          }\r\n        });\r\n        // TODO: Set visibility of the group.\r\n      }\r\n      // Set the commentsChanged property to false to indicate that it is updated.\r\n      drawing.commentsChanged = false;\r\n    }\r\n\r\n    // Update the 'activeDrawing' in the 'activeTool'.\r\n    if (this.activeTool) {\r\n      this.activeTool.activeDrawing = drawing;\r\n    }\r\n    if (this.activeTool && this.activeTool.currentSelection && drawing.content.querySelector('[data-id=\"' + this.activeTool.currentSelection.dataset.id + '\"]')) {\r\n      this.activeTool.currentSelection = drawing.content.querySelector('[data-id=\"' + this.activeTool.currentSelection.dataset.id + '\"]');\r\n      this.activeTool.select(this.activeTool.currentSelection);\r\n    }\r\n\r\n    drawing.content.style.visibility = 'unset';\r\n\r\n    // Set the drawing as active.\r\n    this.activeDrawing = drawing;\r\n  }\r\n\r\n  /**\r\n   * Creates the buttons for the drawings to be displayed.\r\n   * @param {Array} drawings Array with the drawing objects.\r\n   */\r\n  createDrawingsBtns(drawings) {\r\n    let drawingsItems = [];\r\n    drawings.forEach(drawing => {\r\n      // Could be that there is no id if the project was uploaded and it is only local.\r\n      drawingsItems.push(`<li ${drawing.id ? 'data-id=\\\"' + drawing.id + '\\\"' : ''}>${drawing.name}</li>`);\r\n    });\r\n    this.drawingsBtns.querySelector('.dropdown-content').innerHTML = drawingsItems.join('');\r\n  }\r\n\r\n  /**\r\n   * Cleans the workspace by emptying the drawing container and the list of drawings.\r\n   * TODO: Remove possible event listeners before emptying containers ?\r\n   */\r\n  close() {\r\n    // Empty the drawings buttons container.\r\n    _generics__WEBPACK_IMPORTED_MODULE_0__[\"default\"].emptyNode(this.drawingsBtns.querySelector('.dropdown-content'));\r\n    // Remove the create style tag for the styles of the drawings.\r\n    if (this.drawingsStylesTag !== undefined)\r\n      this.drawingsStylesTag.remove();\r\n    // Remove the main panel.   \r\n    //this.mainPanel.kill();\r\n    // TODO: If in future version there are elements in the svg with event listeners those should be deleted\r\n    this.drawingsContainer.innerHTML = '';\r\n  }\r\n}\n\n//# sourceURL=webpack:///./src/workspace.js?");

/***/ })

/******/ });