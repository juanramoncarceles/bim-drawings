/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/api.js":
/*!********************!*\
  !*** ./src/api.js ***!
  \********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _generics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./generics */ \"./src/generics.js\");\n\r\n\r\n/* harmony default export */ __webpack_exports__[\"default\"] = (class {\r\n\r\n  /****** BASIC GOOGLE API FUNCTIONS ******/\r\n\r\n  /**\r\n   * Retrieves id and name of the files that match the query object.\r\n   * @param {Object} query Object with optional entries: name (str), parentId (str), trashed (bool), excludeName (str), and onlyFolder (bool)\r\n   */\r\n  static listFiles(query) {\r\n    const queryItems = [];\r\n    if (query.name) queryItems.push('name=\\'' + query.name + '\\'');\r\n    if (query.parentId) queryItems.push('\\'' + query.parentId + '\\' in parents');\r\n    if (query.trashed === false) queryItems.push('trashed=false');\r\n    if (query.excludeName) queryItems.push('not name contains \\'' + query.excludeName + '\\'');\r\n    if (query.onlyFolder) queryItems.push('mimeType=\\'application/vnd.google-apps.folder\\'');\r\n    let request = gapi.client.drive.files.list({\r\n      'pageSize': 10,\r\n      'fields': \"nextPageToken, files(id, name)\",\r\n      'q': queryItems.join(' and ')\r\n    });\r\n    request.then(res => {\r\n      const files = res.result.files;\r\n      if (files && files.length > 0) {\r\n        console.log(files);\r\n      } else {\r\n        console.log('No files found with this query:', queryItems.join(' and '));\r\n      }\r\n    }, err => {\r\n      console.error(err.body);\r\n    });\r\n    return request;\r\n  }\r\n\r\n\r\n  /**\r\n   * Returns a promise with the contents of the file.\r\n   * @param {String} fileId\r\n   */\r\n  static getFileContent(fileId) {\r\n    let request = gapi.client.drive.files.get({\r\n      fileId: fileId,\r\n      alt: 'media'\r\n    });\r\n    request.then(res => {\r\n      if (res.status === 200)\r\n        console.log('File fetched successfully.');\r\n    }, err => {\r\n      console.error(err.body);\r\n    });\r\n    return request;\r\n  }\r\n\r\n\r\n  /**\r\n   * Returns a promise with the requested data of the file.\r\n   * @param {String} fileId The id of the file to get the data of.\r\n   * @param {String} fields The data to be fetched in format: 'field1, field2'.\r\n   */\r\n  static getFileData(fileId, fields) {\r\n    let request = gapi.client.drive.files.get({\r\n      fileId: fileId,\r\n      fields: fields\r\n    });\r\n    request.then(res => {\r\n      if (res.status === 200) {\r\n        console.log('File data fetched succesfully.');\r\n      }\r\n    }, err => {\r\n      console.error(err);\r\n    });\r\n    return request;\r\n  }\r\n\r\n\r\n  /**\r\n   * Creates a new folder and returns its id.\r\n   * @param {String} title The name of the folder.\r\n   * @param {String} parentId Optional id of the parent folder, if none it will be created on the root.\r\n   */\r\n  static createFolder(title, parentId = 'drive') {\r\n    const body = {\r\n      \"name\": title,\r\n      \"mimeType\": \"application/vnd.google-apps.folder\",\r\n      \"parents\": parentId !== 'drive' ? [parentId] : []\r\n    }\r\n    const request = gapi.client.request({\r\n      'path': 'https://www.googleapis.com/drive/v3/files/',\r\n      'method': 'POST',\r\n      'body': body\r\n    });\r\n    request.then(res => {\r\n      console.log(title + ' folder created. Id: ' + JSON.parse(res.body).id);\r\n    });\r\n    return request;\r\n  }\r\n\r\n\r\n  /**\r\n   * Upload a file to the specific folder.\r\n   * @param {String} fileContent The content of the file as a string.\r\n   * @param {String} fileMimeType The MIME Type of the file. For example: 'application/json'\r\n   * @param {String} fileName Name for the file.\r\n   * @param {String} folderId Id of the parent folder.\r\n   */\r\n  static uploadFile(fileContent, fileMimeType, fileName, folderId) {\r\n    const file = new Blob([fileContent], { type: fileMimeType });\r\n    const metadata = {\r\n      'name': fileName,\r\n      'mimeType': fileMimeType,\r\n      'parents': [folderId]\r\n    };\r\n    const accessToken = gapi.auth.getToken().access_token; // Gapi is used for retrieving the access token.\r\n    const form = new FormData();\r\n    form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));\r\n    form.append('file', file);\r\n\r\n    let request = fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=id', {\r\n      method: 'POST',\r\n      headers: new Headers({ 'Authorization': 'Bearer ' + accessToken }),\r\n      body: form,\r\n    });\r\n    request.then(res => {\r\n      if (res.ok === true && res.status === 200) {\r\n        console.log('Upload of ' + fileName + ' successful.');\r\n      }\r\n    }, err => {\r\n      console.error(err);\r\n    });\r\n    return request;\r\n  }\r\n\r\n\r\n  /**\r\n   * Update the contents of a file.\r\n   * @param {String} fileContent The content of the file as a string.\r\n   * @param {String} fileMimeType The MIME Type of the file. For example: 'application/json'.\r\n   * @param {String} fileId ID of the file to update its content.\r\n   */\r\n  static updateFileContent(fileContent, fileMimeType, fileId) {\r\n    const file = new Blob([fileContent], { type: fileMimeType });\r\n    const metadata = {\r\n      'mimeType': fileMimeType\r\n    };\r\n    const accessToken = gapi.auth.getToken().access_token; // Gapi is used for retrieving the access token.\r\n    const form = new FormData();\r\n    form.append('metadata', new Blob([JSON.stringify(metadata)], { type: 'application/json' }));\r\n    form.append('file', file);\r\n\r\n    let request = fetch(`https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=multipart`, { // Otherwise try uploadType=media\r\n      method: 'PATCH',\r\n      headers: new Headers({ 'Authorization': 'Bearer ' + accessToken }),\r\n      body: form,\r\n    });\r\n    request.then(res => {\r\n      if (res.ok === true && res.status === 200) {\r\n        console.log('Update successful.');\r\n      }\r\n    }, err => {\r\n      console.error(err);\r\n    });\r\n    return request;\r\n  }\r\n\r\n\r\n  /**\r\n   * Rename a file.\r\n   * @param {String} fileId ID of the file to rename.\r\n   * @param {String} newTitle New title for the file.\r\n   */\r\n  static renameFile(fileId, newTitle) {\r\n    var request = gapi.client.drive.files.update({\r\n      'fileId': fileId,\r\n      'name': newTitle,\r\n      'uploadType': 'media'\r\n    });\r\n    request.then(res => {\r\n      console.log(res);\r\n    }, rej => {\r\n      console.log(rej);\r\n    });\r\n  }\r\n\r\n\r\n  /**\r\n   * Permanently delete a file, skipping the trash.\r\n   * @param {String} fileId ID of the file to delete.\r\n   */\r\n  static deleteFile(fileId) {\r\n    let request = gapi.client.drive.files.delete({\r\n      'fileId': fileId\r\n    });\r\n    request.then(res => {\r\n      console.log(res);\r\n    }, rej => {\r\n      console.log(rej);\r\n    });\r\n    return request;\r\n  }\r\n\r\n\r\n  /*******************************************************************/\r\n  /***************** APPLICATION SPECIFIC FUNCTIONS ******************/\r\n  /*******************************************************************/\r\n\r\n  /**\r\n   * Creates a new project folder and a subtructure with all the contents of the project on the file.\r\n   * @param {JSON} file The VisualARQ Drawings file created by the exporter.\r\n   * @param {Object} AppData The AppData object that contains info about the app resources.\r\n   * @param {Object} lastUploadedProject Object with the contents of the last uploaded project.\r\n   */\r\n  static async createProject(file, AppData, lastUploadedProject) {\r\n    // Error message will be stored here if needed.\r\n    let errorMsg;\r\n\r\n    const fileContentRaw = await _generics__WEBPACK_IMPORTED_MODULE_0__[\"default\"].readInputFile(file);\r\n    const fileContent = JSON.parse(fileContentRaw);\r\n    console.log('File contents:', fileContent);\r\n    // TODO: Check if the file is valid... minimum required fields? contents?...\r\n\r\n    // The contents of the file if valid will be saved in the lastUploadedProject variable to be used\r\n    // without the need to fetch them. This allows to view the project even without internet connexion.\r\n    lastUploadedProject.name = fileContent.projectInfo.title;\r\n    lastUploadedProject.drawings = fileContent.drawings;\r\n    lastUploadedProject.elementsData = fileContent.elementsData;\r\n\r\n    // Check if the id of the appMainFolder is in the appData global object.\r\n    // If there is none then try to get it, and if there is none one should be created.\r\n    if (!AppData.appMainFolderId) {\r\n      const appMainFolderRes = await this.listFiles({ name: 'VAviewerData', onlyFolder: true, trashed: false });\r\n      const appMainFolderData = appMainFolderRes.result.files;\r\n      if (appMainFolderData && appMainFolderData.length > 0) {\r\n        AppData.appMainFolderId = appMainFolderData[0].id;\r\n      } else {\r\n        // TODO: This should return a promise to know if something went wrong.\r\n        const appMainFolderRes = await this.createFolder('VAviewerData');\r\n        AppData.appMainFolderId = JSON.parse(appMainFolderRes.body).id;\r\n        console.log('No appFolder found, one is going to be created.');\r\n      }\r\n    }\r\n\r\n    let projectFolderId;\r\n\r\n    // Check if there is already a project with this name in the appData object.\r\n    if (AppData.projectsData === undefined || !AppData.projectsData.find(proj => proj.name === fileContent.projectInfo.title)) {\r\n      try {\r\n        const folderCreationPromise = await this.createFolder(fileContent.projectInfo.title, AppData.appMainFolderId);\r\n        projectFolderId = JSON.parse(folderCreationPromise.body).id;\r\n        lastUploadedProject.id = projectFolderId;\r\n        const projectFolderData = { id: projectFolderId, name: fileContent.projectInfo.title };\r\n        if (AppData.projectsData === undefined) {\r\n          AppData.projectsData = [projectFolderData];\r\n        } else if (!AppData.projectsData.find(proj => proj.name === fileContent.projectInfo.title)) {\r\n          AppData.projectsData.push(projectFolderData);\r\n        }\r\n      } catch (err) {\r\n        console.log(err);\r\n        lastUploadedProject.id = 'temporal';\r\n        errorMsg = JSON.parse(err.body).error.message;\r\n      }\r\n    } else if (AppData.projectsData.find(proj => proj.name === fileContent.projectInfo.title)) {\r\n      // TODO: In case not all projects are loaded how to check if there is already one with this name in the backend?\r\n      // TODO: If there is one already, provide an option to propose another name.\r\n      errorMsg = 'No project was created because there is already a project with this name.';\r\n    } else {\r\n      console.error('Unknown error while attempting to create the project folder.');\r\n    }\r\n\r\n    // Create the drawings subfolder only if there are drawings and if the project folder was created succesfully.\r\n    if (projectFolderId && fileContent.drawings) {\r\n      const drawingsFolderPromise = await this.createFolder('drawings', projectFolderId);\r\n      const drawingsFolderId = JSON.parse(drawingsFolderPromise.body).id;\r\n      AppData.projectsData[AppData.projectsData.length - 1].drawingsFolderId = drawingsFolderId;\r\n      // Upload the drawings.\r\n      const drawingsPromises = [];\r\n      for (const drawing in fileContent.drawings) {\r\n        const drawingPromise = this.uploadFile(fileContent.drawings[drawing], 'image/svg+xml', drawing.concat('.svg'), drawingsFolderId);\r\n        drawingsPromises.push(drawingPromise);\r\n      }\r\n      await Promise.all(drawingsPromises)\r\n        .then(res => {\r\n          // TODO: Is it necessary to check if each response was (res.ok === true && res.status === 200)?\r\n          console.log('Drawings uploaded successfully.');\r\n        }, err => {\r\n          console.error(err);\r\n        });\r\n    }\r\n\r\n    // Create the elementsData subfolder only if there is data and if the project folder was created succesfully.\r\n    if (projectFolderId && fileContent.elementsData) {\r\n      const elementsDataFolderPromise = await this.createFolder('elementsData', projectFolderId);\r\n      const elementsDataFolderId = JSON.parse(elementsDataFolderPromise.body).id;\r\n      AppData.projectsData[AppData.projectsData.length - 1].elementsDataFolderId = elementsDataFolderId;\r\n      // Upload the elements data files.\r\n      const elementsDataPromises = [];\r\n      for (const elementData in fileContent.elementsData) {\r\n        const elementDataPromise = this.uploadFile(JSON.stringify(fileContent.elementsData[elementData]), 'application/json', elementData.concat('.json'), elementsDataFolderId);\r\n        elementsDataPromises.push(elementDataPromise);\r\n      }\r\n      await Promise.all(elementsDataPromises)\r\n        .then(res => {\r\n          // TODO: Is it necessary to check if each response was (res.ok === true && res.status === 200)?\r\n          console.log('ElementsData files uploaded successfully.');\r\n        }, err => {\r\n          console.error(err);\r\n        });\r\n    }\r\n\r\n    // TODO: Check in more detail if the project was created successfully.\r\n    if (projectFolderId) {\r\n      console.log('Upload successful. Uploaded ' + Object.keys(fileContent.drawings).length + ' drawings.');\r\n      return { id: projectFolderId, name: fileContent.projectInfo.title };\r\n    } else {\r\n      // TODO: If the project upload fails the project folder, if created, should be deleted.\r\n      // TODO: Create message with content: Retry again or work offline with the uploaded project.\r\n      return Promise.reject(new Error('Project upload failed. ' + errorMsg));\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Lists the project items.\r\n   * TODO: Limit the amount of projects to fetch.\r\n   * @param {Object} AppData The AppData object that contains info about the app resources.\r\n   */\r\n  static async listProjectItems(AppData) {\r\n    // Gets the id of the app folder using its name if it was not already in the appData object.\r\n    if (!AppData.appMainFolderId) {\r\n      const appMainFolderRes = await this.listFiles({ name: 'VAviewerData', onlyFolder: true, trashed: false });\r\n      const appMainFolderData = appMainFolderRes.result.files;\r\n      if (appMainFolderData && appMainFolderData.length > 0) {\r\n        AppData.appMainFolderId = appMainFolderData[0].id;\r\n      } else {\r\n        console.log('No appFolder found.');\r\n        return Promise.reject(new Error('No appFolder found.'));\r\n      }\r\n    }\r\n\r\n    // Gets the project folders names and ids.\r\n    const projectsFoldersRes = await this.listFiles({ parentId: AppData.appMainFolderId, onlyFolder: true, excludeName: 'appSettings', trashed: false });\r\n    let newProjects;\r\n    const projectsFoldersData = projectsFoldersRes.result.files;\r\n    if (projectsFoldersData && projectsFoldersData.length > 0) {\r\n      if (AppData.projectsData === undefined) {\r\n        newProjects = projectsFoldersData;\r\n        AppData.projectsData = newProjects;\r\n      } else if (Array.isArray(AppData.projectsData)) {\r\n        newProjects = projectsFoldersRes.result.files.filter(newProj => AppData.projectsData.find(proj => proj.id === newProj.id) === undefined);\r\n        newProjects.forEach(proj => {\r\n          AppData.projectsData.push(proj);\r\n        });\r\n      }\r\n    }\r\n    console.assert(AppData.projectsData.length > 0, 'There are no project folders.');\r\n\r\n    // Gets the id of the appSettings folder.\r\n    const appSettFolderRes = await this.listFiles({ parentId: AppData.appMainFolderId, name: 'appSettings', onlyFolder: true });\r\n    const appSettFolderData = appSettFolderRes.result.files;\r\n    if (appSettFolderData && appSettFolderData.length > 0) {\r\n      AppData.appSettingsFolderId = appSettFolderData[0].id;\r\n    } else {\r\n      console.log('No settings folder found.');\r\n    }\r\n\r\n    // Gets the id of the projectsThumbs folder.\r\n    const thumbsFolderRes = await this.listFiles({ parentId: AppData.appSettingsFolderId, name: 'projectsThumbs', onlyFolder: true });\r\n    const thumbsFolderData = thumbsFolderRes.result.files;\r\n    if (thumbsFolderData && thumbsFolderData.length > 0) {\r\n      AppData.thumbsFolderId = thumbsFolderData[0].id;\r\n    } else {\r\n      console.log('No thumbs folder found.');\r\n    }\r\n\r\n    // Gets the data of each thumbnail and assign it to its corresponding project.\r\n    const imgRes = await this.listFiles({ parentId: AppData.thumbsFolderId });\r\n    const imgData = imgRes.result.files;\r\n    AppData.projectsData.forEach(proj => {\r\n      const projectThumbData = imgData.find(img => proj.id === img.name.replace('.jpg', ''));\r\n      if (projectThumbData) {\r\n        proj.thumbId = projectThumbData.id;\r\n      }\r\n    });\r\n    console.assert(imgData.length > 0, 'There are no thumbnails.');\r\n\r\n    // TODO: Missing the management of an error while listing the projects.\r\n\r\n    // If all the required data about the projects was fetched successfully it is returned.\r\n    return newProjects;\r\n  }\r\n\r\n\r\n  /**\r\n   * Fetches the project contents. Specifically the id and the name of all the drawings and elementsData files.\r\n   * It only fetches the resources that are not already in the appData object.\r\n   * TODO: Improve the detection of resources that should be fetched. Currently if there is already any project\r\n   * data for that category (e.g: drawings) in the front it doenst fetch any new file of that category.\r\n   * @param {String} projectId The id of the project.\r\n   * @param {Object} AppData The AppData object that contains info about the app resources.\r\n   */\r\n  static async fetchProject(projectId, AppData) {\r\n    console.log('Fetching project: ' + projectId);\r\n\r\n    let projectIndex;\r\n    // In case the projectsData entry is still undefined this will be the first project to be fetched.\r\n    // This will happen when someone access a project directly with its id in the url.\r\n    if (AppData.projectsData === undefined) {\r\n      const projectNameRes = await this.getFileData(projectId, 'name, trashed');\r\n      if (!JSON.parse(projectNameRes.body).trashed) {\r\n        AppData.projectsData = [{ id: projectId, name: JSON.parse(projectNameRes.body).name }];\r\n        projectIndex = 0;\r\n      }\r\n    } else if (projectId !== 'temporal') {\r\n      projectIndex = AppData.projectsData.findIndex(proj => proj.id === projectId);\r\n    }\r\n\r\n    // If there is no data for projectSettings.json file in the appData yet fetch it.\r\n    if (projectIndex >= 0 && !AppData.projectsData[projectIndex].projSettings) {\r\n      const projSettingsRes = await this.listFiles({ parentId: projectId, name: 'projectSettings.json' });\r\n      const projSettingsData = projSettingsRes.result.files;\r\n      if (projSettingsData && projSettingsData.length > 0) {\r\n        const projSettingsContentRes = await this.getFileContent(projSettingsData[0].id);\r\n        AppData.projectsData[projectIndex].projSettings = projSettingsContentRes.body;\r\n      } else {\r\n        console.log('No projectSettings.json found.');\r\n      }\r\n    }\r\n\r\n    // If there is no data for drawings already fetch the id of the drawings folder and the name and id of each one.\r\n    if (projectIndex >= 0 && !AppData.projectsData[projectIndex].drawings) {\r\n      const drawingsFolderRes = await this.listFiles({ parentId: projectId, onlyFolder: true, name: 'drawings' });\r\n      const drawingsFolderData = drawingsFolderRes.result.files;\r\n      if (drawingsFolderData && drawingsFolderData.length > 0) {\r\n        const drawingsRes = await this.listFiles({ parentId: drawingsFolderData[0].id });\r\n        AppData.projectsData[projectIndex].drawings = {};\r\n        // With this structure there cannot be two drawings with the same name.\r\n        drawingsRes.result.files.forEach(drawing => {\r\n          AppData.projectsData[projectIndex].drawings[drawing.name.replace(/.svg$/, '')] = { id: drawing.id }\r\n        });\r\n      } else {\r\n        console.log('No drawings folder found.');\r\n      }\r\n    }\r\n\r\n    // If there is no data for elementsData already fetch the id of the elementsData folder and the name and id of each one.\r\n    if (projectIndex >= 0 && !AppData.projectsData[projectIndex].elementsData) {\r\n      const elementsDataFolderRes = await this.listFiles({ parentId: projectId, onlyFolder: true, name: 'elementsData' });\r\n      const elementsDataFolderData = elementsDataFolderRes.result.files;\r\n      if (elementsDataFolderData && elementsDataFolderData.length > 0) {\r\n        const elementsDataRes = await this.listFiles({ parentId: elementsDataFolderData[0].id });\r\n        AppData.projectsData[projectIndex].elementsData = elementsDataRes.result.files;\r\n      } else {\r\n        console.log('No elementsData folder found.');\r\n      }\r\n    }\r\n\r\n    // If there is no data for images already fetch the id of the images folder and the name and id of each one.\r\n    if (projectIndex >= 0 && !AppData.projectsData[projectIndex].images) {\r\n      const imagesFolderRes = await this.listFiles({ parentId: projectId, onlyFolder: true, name: 'images' });\r\n      const imagesFolderData = imagesFolderRes.result.files;\r\n      if (imagesFolderData && imagesFolderData.length > 0) {\r\n        const imagesRes = await this.listFiles({ parentId: imagesFolderData[0].id });\r\n        AppData.projectsData[projectIndex].images = imagesRes.result.files;\r\n      } else {\r\n        console.log('No images folder found.');\r\n      }\r\n    }\r\n\r\n    if (projectIndex >= 0) {\r\n      console.log('Project resources fetched succesfully.');\r\n      return AppData.projectsData[projectIndex];\r\n    } else {\r\n      return Promise.reject(new Error('Project resources could not be fetched.'));\r\n    }\r\n  }\r\n\r\n});\n\n//# sourceURL=webpack:///./src/api.js?");

/***/ }),

/***/ "./src/app.js":
/*!********************!*\
  !*** ./src/app.js ***!
  \********************/
/*! exports provided: Application */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Application\", function() { return Application; });\n/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./api */ \"./src/api.js\");\n/* harmony import */ var _workspace__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./workspace */ \"./src/workspace.js\");\n/* harmony import */ var _projectData__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./projectData */ \"./src/projectData.js\");\n/* harmony import */ var _generics__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./generics */ \"./src/generics.js\");\n/* harmony import */ var _appTools_addComment__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./appTools/addComment */ \"./src/appTools/addComment.js\");\n/* harmony import */ var _appTools_elementData__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./appTools/elementData */ \"./src/appTools/elementData.js\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass Application {\r\n  constructor() {\r\n    this.appMainFolderId = undefined;\r\n    // projectsData: Array of objects with data like name and id of the projects.\r\n    this.projectsData = undefined;\r\n    this.appSettingsFolderId = undefined;\r\n    this.thumbsFolderId = undefined;\r\n    this.workspace = undefined;\r\n    this.lastUploadedProject = new _projectData__WEBPACK_IMPORTED_MODULE_2__[\"ProjectData\"]();\r\n    // Stores the active item in the projects list.\r\n    this.previousActiveItem;\r\n    this.projectsListBtn = document.getElementById('projectsListBtn');\r\n    this.drawingsContainer = document.getElementById('drawingsContainer');\r\n    this.drawingsBtns = document.getElementById('drawingsBtns');\r\n    this.toolbarsContainer = document.getElementById('toolbarsContainer');\r\n    this.modalDialogContainer = document.getElementById('modalDialogContainer');\r\n    this.modalDialogsStorage = document.getElementById('modalDialogsStorage');\r\n    this.viewportMessage = document.getElementById('viewportMessage');\r\n    this.projectsListContainer = document.getElementById('projectsListContainer');\r\n    this.projectsList = document.getElementById('projectsList');\r\n    this.closeProjectsListBtn = document.getElementById('closeProjectsListBtn');\r\n    this.showProjectsList = this.showProjectsList.bind(this);\r\n    this.projectsListBtn.addEventListener('click', this.showProjectsList);\r\n    this.closeProjectsListBtn.addEventListener('click', () => {\r\n      this.projectsListContainer.style.display = 'none';\r\n      this.drawingsBtns.style.display = 'unset';\r\n      this.toolbarsContainer.style.display = 'flex';\r\n    });\r\n    this.projectsList.addEventListener('click', e => {\r\n      const projectItem = e.target.closest('[data-proj-id]');\r\n      if (projectItem === null) {\r\n        return;\r\n      }\r\n      // If it is the current project close the list window.\r\n      if (this.workspace && this.workspace.projectId === projectItem.dataset.projId) {\r\n        return;\r\n      }\r\n      // TODO: If there have been changes in the project ask to save or discard them before closing it.\r\n      // TODO: If it was an offline project try to sync it before closing it. The id would be 'temporal' and the contents in currentProject\r\n      if (projectItem.dataset.projId === this.lastUploadedProject.id) {\r\n        if (this.lastUploadedProject.id === 'temporal') {\r\n          console.log('Show a message indicating that the project can be accessed but in viewer mode because it couldnt be saved.');\r\n        }\r\n        this.goToProject(this.lastUploadedProject);\r\n        if (this.previousActiveItem) {\r\n          this.previousActiveItem.classList.remove('current');\r\n        }\r\n        projectItem.classList.add('current');\r\n        this.previousActiveItem = projectItem;\r\n        this.projectsListBtn.style.display = 'unset';\r\n      } else {\r\n        this.showViewportDialog('loader', `Loading project ${projectItem.dataset.name}`);\r\n        _api__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fetchProject(projectItem.dataset.projId, this)\r\n          .then(res => {\r\n            this.goToProject(res);\r\n            if (this.previousActiveItem) {\r\n              this.previousActiveItem.classList.remove('current');\r\n            }\r\n            projectItem.classList.add('current');\r\n            this.previousActiveItem = projectItem;\r\n            this.projectsListBtn.style.display = 'unset';\r\n            this.hideViewportMessage();\r\n          }, err => {\r\n            console.log(err);\r\n          });\r\n      }\r\n    });\r\n    window.onresize = this.adjustItems;\r\n    // TODO: This would make more sense as part of the workspace ?\r\n    document.getElementById('tool-4').addEventListener('click', (e) => this.workspace.manageTools(e, _appTools_addComment__WEBPACK_IMPORTED_MODULE_4__[\"AddComment\"], 'commentsTool'));\r\n    document.getElementById('tool-3').addEventListener('click', (e) => this.workspace.manageTools(e, _appTools_elementData__WEBPACK_IMPORTED_MODULE_5__[\"ElementData\"], 'elementsDataTool'));\r\n  }\r\n\r\n\r\n  /************************ THE PROJECTS LIST ************************/\r\n\r\n  /**\r\n   * Sets the workspace with the provided project.\r\n   * @param {Object} project Data of the project. Id, name, drawings ids and elementsData files ids.\r\n   */\r\n  goToProject(project) {\r\n    if (this.workspace) {\r\n      this.workspace.close();\r\n    }\r\n    this.workspace = new _workspace__WEBPACK_IMPORTED_MODULE_1__[\"Workspace\"](project, this);\r\n    this.projectsListContainer.style.display = 'none';\r\n    history.replaceState({ projectTitle: project.name }, project.name, \"?id=\" + project.id); // encodeURIComponent ? use pushState() ?\r\n  }\r\n\r\n  /**\r\n   * Shows the list of projects container and fetches projects if required.\r\n   */\r\n  showProjectsList() {\r\n    console.log('Show the projects list.');\r\n    if (this.workspace !== undefined) {\r\n      this.closeProjectsListBtn.style.display = 'unset';\r\n    } else {\r\n      this.closeProjectsListBtn.style.display = 'none';\r\n    }\r\n    this.projectsListContainer.style.display = 'block';\r\n    // Hide the drawings and tools buttons\r\n    this.drawingsBtns.style.display = 'none';\r\n    this.toolbarsContainer.style.display = 'none';\r\n    // If there is no projectsData or if there is only one fetch projects.\r\n    if (this.projectsData === undefined || this.projectsData.length <= 1) {\r\n      this.showViewportDialog('loader', 'Loading projects');\r\n      _api__WEBPACK_IMPORTED_MODULE_0__[\"default\"].listProjectItems(this).then(res => {\r\n        this.createHTMLProjectsList(res);\r\n        // Set the 'current' class in the current project.\r\n        this.projectsList.childNodes.forEach(proj => {\r\n          if (proj.dataset && proj.dataset.projId === this.workspace.projectId) {\r\n            proj.classList.add('current');\r\n            this.previousActiveItem = proj;\r\n          }\r\n        });\r\n        this.hideViewportMessage();\r\n      }, rej => {\r\n        this.projectsList.innerHTML = '<p class=\"empty-msg\">There are no projects. Upload one!</p>';\r\n        this.hideViewportMessage();\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create an HTML element with the project data provided.\r\n   * @param {Object} projData Object with name, id and optional thumbId entries.\r\n   */\r\n  createProjectItem(projData) {\r\n    const projItem = document.createElement('button');\r\n    // Projects that have been uploaded but not send to the backend have an id of 'temporal'.\r\n    if (projData.id === 'temporal') {\r\n      projItem.classList.add('unsync');\r\n    }\r\n    projItem.dataset.projId = projData.id;\r\n    projItem.dataset.name = projData.name;\r\n    projItem.classList.add('projectItem');\r\n    let projItemContent;\r\n    if (projData.thumbId) {\r\n      projItemContent = `<img src='https://drive.google.com/uc?id=${projData.thumbId}'>`;\r\n    } else {\r\n      projItemContent = `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"-100 -50 350 210\"><path d=\"M143,10.44H65.27V7a7,7,0,0,0-7-7H7A7,7,0,0,0,0,7V103a7,7,0,0,0,7,7H65V70.18H85V110h58a7,7,0,0,0,7-7V17.41A7,7,0,0,0,143,10.44ZM125,53.49H105v-20h20Z\" style=\"fill:#e6e6e6\"/></svg>`;\r\n    }\r\n    projItem.innerHTML = projItemContent.concat(`<h4>${projData.name}</h4>`);\r\n    return projItem;\r\n  }\r\n\r\n  /**\r\n   * Receives an array of projects data and creates and appends the HTML items.\r\n   * @param {Array} projectsData The project objects with the name, id and optional thumbId entries.\r\n   */\r\n  createHTMLProjectsList(projectsData) {\r\n    projectsData.forEach(proj => {\r\n      const projectItem = this.createProjectItem(proj);\r\n      this.projectsList.appendChild(projectItem);\r\n    });\r\n    this.adjustItems();\r\n  }\r\n\r\n  /**\r\n   * Adjusts the position of project items in the container.\r\n   */\r\n  adjustItems() {\r\n    const itemsH = getComputedStyle(this.projectsList).getPropertyValue('--items-h');\r\n    const itemsTotal = this.projectsList.children.length;\r\n    this.projectsList.style.setProperty('--remaining-items', (Math.ceil(itemsTotal / itemsH) * itemsH) - itemsTotal);\r\n  }\r\n\r\n  /**\r\n   *  Adds a new HTML element item to the list of projects.\r\n   * @param {Object} projData Object with name, id and optional thumbId entries.\r\n   */\r\n  updateProjectsList(projData) {\r\n    const projectItem = this.createProjectItem(projData);\r\n    // Remove the 'no projects yet' message if it is the first.\r\n    if (this.projectsData.length <= 1) {\r\n      this.projectsList.querySelector('.empty-msg').remove();\r\n    }\r\n    this.projectsList.prepend(projectItem);\r\n    this.adjustItems();\r\n  }\r\n\r\n\r\n  /*********************** VIEWPORT MESSAGES ***********************/\r\n  /*\r\n   * A message on the middle of the viewport that interrupts.\r\n   */\r\n\r\n  /**\r\n   * Manages the creation of a message on the viewport.\r\n   * @param {String} type Values 'loader' or 'action'. If action an object with a function reference and a name should be provided.\r\n   * @param {String} message \r\n   * @param {Array} actions Array of objects with name and function entries.\r\n   */\r\n  showViewportDialog(type, message, actions) {\r\n    if (this.viewportMessage.querySelector('.btns-container')) {\r\n      this.viewportMessage.querySelectorAll('.btns-container > button').forEach(btn => btn.onclick = null);\r\n    }\r\n    _generics__WEBPACK_IMPORTED_MODULE_3__[\"default\"].emptyNode(this.viewportMessage);\r\n    // Create the new content.\r\n    const innerContainer = document.createElement('div');\r\n    if (type === 'loader') {\r\n      innerContainer.innerHTML = `<p>${message}</p><svg class=\"svg-loader\"><use href=\"#vaLoader\"/></svg>`;\r\n    } else if (type === 'action') {\r\n      innerContainer.innerHTML = `<p>${message}</p>`;\r\n      const btnsContainer = document.createElement('div');\r\n      btnsContainer.classList.add('btns-container');\r\n      actions.forEach(action => {\r\n        const button = document.createElement('button');\r\n        button.innerHTML = action.name;\r\n        button.classList.add('buttonBase', 'light');\r\n        button.onclick = action.function;\r\n        btnsContainer.appendChild(button);\r\n      });\r\n      innerContainer.appendChild(btnsContainer);\r\n    } else if (type === 'message') { // Is this one useful? Maybe with a setTimeout?\r\n      innerContainer.innerHTML = '<p>' + message + '</p>';\r\n    }\r\n    this.viewportMessage.appendChild(innerContainer);\r\n    this.viewportMessage.classList.add('active');\r\n  }\r\n\r\n  /**\r\n   * Hides the viewport message if visible.\r\n   */\r\n  hideViewportMessage() {\r\n    this.viewportMessage.classList.remove('active');\r\n  }\r\n\r\n\r\n  /********************* MODAL DIALOGS *********************/\r\n  /*\r\n   * All modal dialogs are stored in a container and fetched when needed.\r\n   */\r\n\r\n  /**\r\n   * Shows the modal dialog provided from the same document.\r\n   * @param {HTMLElement} dialog Reference to the outer HTML element of the dialog.\r\n   */\r\n  showModalDialog(dialog) {\r\n    this.modalDialogContainer.appendChild(dialog);\r\n    this.modalDialogContainer.style.display = 'flex';\r\n  }\r\n\r\n  /**\r\n   * Hides the modal dialog provided from the same document.\r\n   * @param {HTMLElement} dialog Reference to the outer HTML element of the dialog.\r\n   */\r\n  closeModalDialog(dialog) {\r\n    this.modalDialogContainer.style.display = 'none';\r\n    this.modalDialogsStorage.appendChild(dialog);\r\n  }\r\n\r\n\r\n  /********************* START THE APPLICATION *********************/\r\n\r\n  /**\r\n   * Method called at start and behaves differently depending if the url contains an id of a project or not.\r\n   */\r\n  start() {\r\n    // Hide the login dialog in case it was visible.\r\n    this.closeModalDialog(authorizeDialog);\r\n    // Show the app interface.\r\n    document.querySelector('header').style.display = 'flex';\r\n    document.querySelector('main').style.display = 'block';\r\n    // Get the URL params.\r\n    const resourceId = _generics__WEBPACK_IMPORTED_MODULE_3__[\"default\"].getUrlParams(window.location.href).id;\r\n    if (resourceId) {\r\n      this.showViewportDialog('loader', 'Loading project');\r\n      _api__WEBPACK_IMPORTED_MODULE_0__[\"default\"].fetchProject(resourceId, this)\r\n        .then(res => {\r\n          this.workspace = new _workspace__WEBPACK_IMPORTED_MODULE_1__[\"Workspace\"](res, this);\r\n          this.createHTMLProjectsList([res]);\r\n          this.projectsListBtn.style.display = 'unset';\r\n          this.hideViewportMessage();\r\n        }, rej => {\r\n          console.log(rej);\r\n          const errorMessage = rej.body === undefined ? rej : `Message: ${JSON.parse(rej.body).error.message} Code: ${JSON.parse(rej.body).error.code}`;\r\n          this.showViewportDialog('action', errorMessage, [\r\n            {\r\n              name: 'View projects list',\r\n              function: () => {\r\n                this.showProjectsList();\r\n                if (location.search !== \"\") {\r\n                  history.replaceState({ page: 'Projects list' }, 'Projects list', location.href.replace(location.search, ''));\r\n                }\r\n              }\r\n            }\r\n          ]);\r\n        });\r\n    } else {\r\n      // Delete any invalid search parameter if any.\r\n      if (location.search !== \"\") {\r\n        history.replaceState({ page: 'Projects list' }, 'Projects list', location.href.replace(location.search, ''));\r\n      }\r\n      this.projectsListContainer.style.display = 'block';\r\n      this.showViewportDialog('loader', 'Loading projects');\r\n      // TODO: Limit the number of projects to list\r\n      _api__WEBPACK_IMPORTED_MODULE_0__[\"default\"].listProjectItems(this).then(res => {\r\n        this.createHTMLProjectsList(res);\r\n        this.hideViewportMessage();\r\n      }, rej => {\r\n        this.projectsList.innerHTML = '<p class=\"empty-msg\">There are no projects. Upload one!</p>';\r\n        this.hideViewportMessage();\r\n      });\r\n    }\r\n  }\r\n}\n\n//# sourceURL=webpack:///./src/app.js?");

/***/ }),

/***/ "./src/appTools/addComment.js":
/*!************************************!*\
  !*** ./src/appTools/addComment.js ***!
  \************************************/
/*! exports provided: AddComment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AddComment\", function() { return AddComment; });\n/* harmony import */ var _generics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../generics */ \"./src/generics.js\");\n/* harmony import */ var _elementSelection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./elementSelection */ \"./src/appTools/elementSelection.js\");\n\r\n\r\n\r\nclass AddComment extends _elementSelection__WEBPACK_IMPORTED_MODULE_1__[\"ElementSelection\"] {\r\n  constructor(name, workspace) {\r\n    super(name, workspace);\r\n    console.log('Comments tool activated!');\r\n    this.boundingBox;\r\n    this.waitingForComment = false;\r\n    this.commentForm = workspace.commentForm;\r\n    this.input = commentForm.elements[\"comment\"];\r\n    this.comments = workspace.comments;\r\n    this.activeDrawing = workspace.activeDrawing; // this is already in super\r\n    this.addComment = this.addComment.bind(this);\r\n    this.commentForm.onsubmit = this.addComment;\r\n  }\r\n\r\n  /**\r\n   * Extends the method of the super class to get the selected element.\r\n   * @param {MouseEvent} e The click event.\r\n   */\r\n  manageSelection(e) {\r\n    if (!this.waitingForComment) {\r\n      super.manageSelection(e);\r\n      if (this.selection !== null) {\r\n        console.log('Add comment to: ', this.selection);\r\n        // Show the form to add the comment:\r\n        this.commentForm.style.display = 'unset';\r\n        this.waitingForComment = true;\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  /**\r\n   * Creates a comment on the drawing if it has the element on the comment obj\r\n   * @param {*} element \r\n   * @param {*} commentsGroup \r\n   * @param {*} comment \r\n   */\r\n  static createSvgComment(element, commentsGroup) {\r\n    const boundingBox = _generics__WEBPACK_IMPORTED_MODULE_0__[\"default\"].createBBox(element);\r\n    boundingBox.setAttribute('style', 'fill:none;stroke:#000;');\r\n    boundingBox.dataset.id = 'c-' + element.dataset.id;\r\n    commentsGroup.appendChild(boundingBox);\r\n    return boundingBox;\r\n  }\r\n\r\n\r\n  addComment(e) {\r\n    e.preventDefault();\r\n    // If 'activeDrawing' doesnt have a group for comments create it.\r\n    let commentsGroup;\r\n    if (this.activeDrawing.querySelector('g[comments]') !== null) {\r\n      commentsGroup = this.activeDrawing.querySelector('g[comments]');\r\n    } else {\r\n      commentsGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');\r\n      commentsGroup.setAttribute('comments', '');\r\n      this.activeDrawing.querySelector('svg').appendChild(commentsGroup);\r\n    }\r\n    const uiComment = this.constructor.createSvgComment(this.selection, commentsGroup);\r\n\r\n    this.comments.push({\r\n      id: uiComment.dataset.id,\r\n      elementId: this.selection.dataset.id,\r\n      content: this.input.value,\r\n      uiElements: [uiComment]\r\n    });\r\n    console.log(this.comments);\r\n    this.input.value = '';\r\n    this.commentForm.style.display = 'none';\r\n    this.waitingForComment = false;\r\n    super.deselect();\r\n  }\r\n\r\n\r\n  kill() {\r\n    super.kill();\r\n    console.log('Comment tool killed!');\r\n    if (this.waitingForComment) {\r\n      this.commentForm.style.display = 'none';\r\n      this.input.value = '';\r\n    }\r\n    // Remove the tool event listener.\r\n    this.commentForm.onsubmit = null;\r\n  }\r\n}\n\n//# sourceURL=webpack:///./src/appTools/addComment.js?");

/***/ }),

/***/ "./src/appTools/elementData.js":
/*!*************************************!*\
  !*** ./src/appTools/elementData.js ***!
  \*************************************/
/*! exports provided: ElementData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ElementData\", function() { return ElementData; });\n/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../api */ \"./src/api.js\");\n/* harmony import */ var _elementSelection__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./elementSelection */ \"./src/appTools/elementSelection.js\");\n\r\n\r\n\r\nclass ElementData extends _elementSelection__WEBPACK_IMPORTED_MODULE_1__[\"ElementSelection\"] {\r\n  constructor(name, workspace) {\r\n    super(name, workspace);\r\n    console.log('Elements data tool activated!');\r\n    this.elementsData = workspace.elementsData;\r\n    this.projectsData = workspace.projectsData;\r\n    this.projectIndex = workspace.projectIndex;\r\n    this.currentElementData;\r\n  }\r\n\r\n  /**\r\n   * Extends the method of the super class to get the selected element.\r\n   * @param {MouseEvent} e The click event.\r\n   */\r\n  manageSelection(e) {\r\n    super.manageSelection(e);\r\n    if (this.selection !== null) {\r\n      this.showElementData(this.selection.dataset.category, this.selection.dataset.id);\r\n    } else if (this.currentElementData) {\r\n      // TODO: Clean the data table.\r\n      this.currentElementData = undefined;\r\n      console.log('Clean the data table');\r\n    }\r\n  }\r\n\r\n\r\n  /******************** ELEMENTS ASSOCIATED DATA *******************/\r\n\r\n  /**\r\n   * Shows the data associated with the selected element by fetching it if needed.\r\n   * @param {String} category \r\n   * @param {String} id \r\n   */\r\n  showElementData(category, id) {\r\n    if (this.elementsData[category]) {\r\n      this.currentElementData = this.elementsData[category].instances[id];\r\n      console.log(this.currentElementData);\r\n    } else {\r\n      const categoryData = this.projectsData[this.projectIndex].elementsData.find(obj => obj.name.replace('.json', '') === category);\r\n      if (categoryData !== undefined) {\r\n        // TODO: show a loader in the table.\r\n        _api__WEBPACK_IMPORTED_MODULE_0__[\"default\"].getFileContent(categoryData.id).then(res => {\r\n          this.elementsData[category] = JSON.parse(res.body);\r\n          // TODO: hide the loader in the table.\r\n          this.currentElementData = this.elementsData[category].instances[id];\r\n          console.log(this.currentElementData);\r\n        }, err => {\r\n          // TODO: hide the loader in the table.\r\n          console.log(err);\r\n        });\r\n      } else {\r\n        console.log('There is no data for that element.');\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  kill() {\r\n    super.kill();\r\n    console.log('Elements data tool killed!');\r\n    // TODO: Clear the data table.\r\n  }\r\n}\n\n//# sourceURL=webpack:///./src/appTools/elementData.js?");

/***/ }),

/***/ "./src/appTools/elementSelection.js":
/*!******************************************!*\
  !*** ./src/appTools/elementSelection.js ***!
  \******************************************/
/*! exports provided: ElementSelection */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ElementSelection\", function() { return ElementSelection; });\nclass ElementSelection {\r\n  constructor(name, workspace) {\r\n    this.name = name;\r\n    this.activeDrawing = workspace.activeDrawing;\r\n    this.currentSelection;\r\n    this.selection; // TODO: Rename as clickedElement ?\r\n    this.drawingsContainer = workspace.drawingsContainer;\r\n    this.manageSelection = this.manageSelection.bind(this);\r\n    this.drawingsContainer.addEventListener('click', this.manageSelection);\r\n  }\r\n\r\n\r\n  /********************* SELECTION OF ELEMENTS *********************/\r\n\r\n  /**\r\n   * Manages the selection and deselection of the svg elements.\r\n   * This should be extended to obtain the selected element.\r\n   * @param {MouseEvent} e The click event.\r\n   */\r\n  manageSelection(e) {\r\n    this.selection = e.target.closest('[selectable]');\r\n    if (this.selection !== null) {\r\n      if (this.currentSelection === undefined) {\r\n        this.selection.classList.add('selected');\r\n        this.currentSelection = this.selection;\r\n      } else if (this.selection.dataset.id !== this.currentSelection.dataset.id) {\r\n        if (this.activeDrawing.querySelector('[data-id=\"' + this.currentSelection.dataset.id + '\"]')) {\r\n          this.currentSelection.classList.remove('selected');\r\n        }\r\n        this.selection.classList.add('selected');\r\n        this.currentSelection = this.selection;\r\n      }\r\n    } else if (this.currentSelection !== undefined) {\r\n      if (this.activeDrawing.querySelector('[data-id=\"' + this.currentSelection.dataset.id + '\"]')) {\r\n        this.currentSelection.classList.remove('selected');\r\n      }\r\n      this.currentSelection = undefined;\r\n    }\r\n  }\r\n\r\n\r\n  deselect() {\r\n    if (this.currentSelection) {\r\n      this.currentSelection.classList.remove('selected');\r\n      this.currentSelection = undefined;\r\n    }\r\n  }\r\n\r\n\r\n  kill() {\r\n    this.drawingsContainer.removeEventListener('click', this.manageSelection);\r\n    this.deselect();\r\n  }\r\n}\n\n//# sourceURL=webpack:///./src/appTools/elementSelection.js?");

/***/ }),

/***/ "./src/generics.js":
/*!*************************!*\
  !*** ./src/generics.js ***!
  \*************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (class {\r\n\r\n  /**\r\n  * Read the content of a file.\r\n  * @param {Blob} file \r\n  */\r\n  static readInputFile(file) {\r\n    return new Promise((res, rej) => {\r\n      const reader = new FileReader();\r\n      reader.readAsText(file, \"UTF-8\");\r\n      reader.onload = () => {\r\n        res(reader.result);\r\n      }\r\n      reader.onerror = () => {\r\n        console.log(\"Error reading the file.\");\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n  * Get the URL parameters.\r\n  * Source: https://css-tricks.com/snippets/javascript/get-url-variables/\r\n  * @param  {String} url The URL\r\n  * @return {Object}     The URL parameters\r\n  */\r\n  static getUrlParams(url) {\r\n    const params = {};\r\n    const parser = document.createElement('a');\r\n    parser.href = url;\r\n    const vars = parser.search.substring(1).split('&');\r\n    for (let i = 0; i < vars.length; i++) {\r\n      const pair = vars[i].split('=');\r\n      params[pair[0]] = decodeURIComponent(pair[1]);\r\n    }\r\n    return params;\r\n  }\r\n\r\n  /**\r\n   * Removes all the childs of the HTML element.\r\n   * @param {HTMLElement} node \r\n   */\r\n  static emptyNode(node) {\r\n    while (node.firstChild && node.removeChild(node.firstChild));\r\n  }\r\n\r\n  /**\r\n   * Creates a fillet bounding box around the provided element.\r\n   * @param {SVGElement} element \r\n   * @param {Number} offset Optional, with default 5.\r\n   * @param {Number} fillet Optional, with default 5.\r\n   */\r\n  static createBBox(element, offset = 5, fillet = 5) {\r\n    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\r\n    rect.setAttribute('x', element.getBBox().x - offset);\r\n    rect.setAttribute('y', element.getBBox().y - offset);\r\n    rect.setAttribute('width', element.getBBox().width + offset * 2);\r\n    rect.setAttribute('height', element.getBBox().height + offset * 2);\r\n    rect.setAttribute('rx', fillet);\r\n    rect.setAttribute('ry', fillet);\r\n    return rect;\r\n  }\r\n});\r\n\n\n//# sourceURL=webpack:///./src/generics.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./app */ \"./src/app.js\");\n/* harmony import */ var _generics__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./generics */ \"./src/generics.js\");\n/* harmony import */ var _api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./api */ \"./src/api.js\");\n\r\n\r\n\r\n\r\n\r\n/****************** THE ONLY INSTANCE OF THE APP *******************/\r\n\r\nconst App = new _app__WEBPACK_IMPORTED_MODULE_0__[\"Application\"]();\r\n\r\n\r\n/************************** AUTHENTICATION *************************/\r\n\r\n\r\n// Client ID and API key from the Developer Console\r\nconst CLIENT_ID = '199844453643-0s921ir25l6rrventemkvr5te5aattej.apps.googleusercontent.com';\r\nconst API_KEY = 'AIzaSyDgot_h8p7RzZunGoSDVlKxrpUNN97rPeg';\r\n\r\n// Array of API discovery doc URLs for APIs used by the quickstart\r\nconst DISCOVERY_DOCS = [\"https://www.googleapis.com/discovery/v1/apis/drive/v3/rest\"];\r\n\r\n// Authorization scopes required by the API; multiple scopes can be\r\n// included, separated by spaces.\r\nconst SCOPES = 'https://www.googleapis.com/auth/drive';\r\n\r\nconst authorizeButton = document.getElementById('authorizeBtn');\r\nconst signoutButton = document.getElementById('signoutBtn');\r\n\r\n\r\n/**\r\n *  On load, called to load the auth2 library and API client library.\r\n */\r\n(function () {\r\n  const script = document.createElement('script');\r\n  script.type = \"text/javascript\";\r\n  script.defer = true;\r\n  script.onload = () => handleClientLoad();\r\n  script.src = 'https://apis.google.com/js/api.js';\r\n  document.querySelector('body').appendChild(script);\r\n})();\r\n\r\n\r\nfunction handleClientLoad() {\r\n  gapi.load('client:auth2', initClient);\r\n}\r\n\r\n\r\n/**\r\n *  Initializes the API client library and sets up sign-in state listeners.\r\n */\r\nfunction initClient() {\r\n  gapi.client.init({\r\n    apiKey: API_KEY,\r\n    clientId: CLIENT_ID,\r\n    discoveryDocs: DISCOVERY_DOCS,\r\n    scope: SCOPES\r\n  }).then(function () {\r\n    // Listen for sign-in state changes.\r\n    gapi.auth2.getAuthInstance().isSignedIn.listen(updateSigninStatus);\r\n\r\n    // Handle the initial sign-in state.\r\n    updateSigninStatus(gapi.auth2.getAuthInstance().isSignedIn.get());\r\n    authorizeButton.onclick = handleAuthClick;\r\n    signoutButton.onclick = handleSignoutClick;\r\n  }, function (error) {\r\n    console.log(JSON.stringify(error, null, 2));\r\n  });\r\n}\r\n\r\n\r\n/**\r\n *  Called when the signed in status changes, to update the UI\r\n *  appropriately. After a sign-in, the API is called.\r\n */\r\nfunction updateSigninStatus(isSignedIn) {\r\n  if (isSignedIn) {\r\n    console.log('Authorized.');\r\n    App.start();\r\n  } else {\r\n    console.log('Not authorized');\r\n    showLoginDialog();\r\n  }\r\n}\r\n\r\n\r\n/**\r\n *  Sign in the user upon button click.\r\n */\r\nfunction handleAuthClick(event) {\r\n  gapi.auth2.getAuthInstance().signIn();\r\n}\r\n\r\n\r\n/**\r\n *  Sign out the user upon button click.\r\n */\r\nfunction handleSignoutClick(event) {\r\n  gapi.auth2.getAuthInstance().signOut();\r\n}\r\n\r\n\r\n/************************** LOGIN DIALOG ***************************/\r\n\r\n\r\nconst authorizeDialog = document.getElementById('authorizeDialog');\r\n\r\n/**\r\n * Shows the login dialog and hides and clears anything else.\r\n */\r\nfunction showLoginDialog() {\r\n  App.showModalDialog(authorizeDialog);\r\n  // Hide anything else.\r\n  document.querySelector('header').style.display = 'none';\r\n  document.querySelector('main').style.display = 'none';\r\n  App.projectsListContainer.style.display = 'none';\r\n  // TODO: Delete the contents of the global objects if any.\r\n  // appData.clear();\r\n  // currentProject.clear();\r\n  // lastUploadedProject.clear();\r\n  _generics__WEBPACK_IMPORTED_MODULE_1__[\"default\"].emptyNode(App.projectsList);\r\n  history.replaceState({ page: 'Sign in dialog' }, 'Sign in dialog', location.href.replace(location.search, ''));\r\n}\r\n\r\n\r\n/********************* UPLOAD FILE FORM DIALOG *********************/\r\n\r\n\r\nconst uploadFileForm = document.getElementById('uploadFileForm');\r\nconst fileInput = document.getElementById('fileInput');\r\nconst submitFileBtn = uploadFileForm.querySelector('button[type=\"submit\"]');\r\n\r\n// Show the upload project form.\r\ndocument.getElementById('newProjectBtn').addEventListener('click', () => {\r\n  App.showModalDialog(uploadFileForm);\r\n  App.modalDialogContainer.classList.add('grayTranslucent');\r\n});\r\n\r\n\r\n// Hide the upload project form.\r\ndocument.getElementById('closeUploadForm').addEventListener('click', () => {\r\n  App.closeModalDialog(uploadFileForm);\r\n  App.modalDialogContainer.classList.remove('grayTranslucent');\r\n});\r\n\r\n\r\n// Listen to file input changes.\r\nfileInput.addEventListener('change', () => {\r\n  if (fileInput.files.length > 0) {\r\n    fileInput.nextElementSibling.innerHTML = fileInput.files[0].name;\r\n    submitFileBtn.classList.remove('disabled');\r\n  } else {\r\n    fileInput.nextElementSibling.innerHTML = 'Choose a file';\r\n    submitFileBtn.classList.add('disabled');\r\n  }\r\n});\r\n\r\n\r\nuploadFileForm.onsubmit = e => {\r\n  e.preventDefault();\r\n  // Set loading state on UI.\r\n  document.getElementById('loadingFile').style.display = 'unset';\r\n  submitFileBtn.classList.add('disabled');\r\n  submitFileBtn.innerHTML = 'Uploading file';\r\n  fileInput.nextElementSibling.style.display = 'none';\r\n  const file = e.target.elements[\"file\"].files[0];\r\n  // TODO: Show some real progress while creating the project.\r\n  _api__WEBPACK_IMPORTED_MODULE_2__[\"default\"].createProject(file, App, App.lastUploadedProject).then(res => {\r\n    App.updateProjectsList(res);\r\n    App.closeModalDialog(uploadFileForm);\r\n    showMessage('success', 'Project uploaded successfully.');\r\n    fileInput.value = '';\r\n    // Reset upload form UI.\r\n    document.getElementById('loadingFile').style.display = 'none';\r\n    fileInput.nextElementSibling.innerHTML = 'Choose a file';\r\n    submitFileBtn.innerHTML = 'Upload';\r\n    fileInput.nextElementSibling.style.display = 'unset';\r\n  }, err => {\r\n    App.closeModalDialog(uploadFileForm);\r\n    App.updateProjectsList(App.lastUploadedProject);\r\n    console.error(err);\r\n  });\r\n}\r\n\r\n\r\n/************************ MESSAGE CONTAINER ************************/\r\n/*\r\n * It is a message that works as a feedback and that doesnt interrupt.\r\n */\r\n\r\n\r\nconst messageContainer = document.getElementById('messageContainer');\r\n\r\n/**\r\n * Disaplays feedback message.\r\n * @param {String} message \r\n * @param {String} type Use keywords 'success', 'warning' or 'error' to specify the type of message.\r\n */\r\nfunction showMessage(type, message) {\r\n  messageContainer.style.display = 'flex';\r\n  messageContainer.querySelector('p').innerText = message;\r\n  switch (type) {\r\n    case 'success':\r\n      messageContainer.classList.add('success');\r\n      break;\r\n    case 'warning':\r\n      messageContainer.classList.add('warning');\r\n      break;\r\n    case 'error':\r\n      messageContainer.classList.add('error');\r\n      break;\r\n  }\r\n}\r\n\r\nmessageContainer.querySelector('button').addEventListener('click', () => {\r\n  messageContainer.style.display = 'none';\r\n});\r\n\r\n\r\n/********************** DRAWINGS BUTTONS LIST **********************/\r\n/*\r\n * A single event listener in the container of the drawings buttons manages the clicked drawing.\r\n */\r\n\r\n\r\nlet currentDrawingBtn;\r\n\r\nApp.drawingsBtns.querySelector('.dropdown-content').addEventListener('click', e => {\r\n  if (currentDrawingBtn) {\r\n    currentDrawingBtn.classList.remove('active');\r\n  }\r\n  currentDrawingBtn = e.target;\r\n  const drawingName = currentDrawingBtn.innerText;\r\n  App.drawingsBtns.children[0].innerText = drawingName;\r\n  currentDrawingBtn.classList.add('active');\r\n  if (App.workspace.drawings[drawingName]) {\r\n    App.workspace.setDrawing(drawingName);\r\n  } else {\r\n    App.showViewportDialog('loader', 'Loading drawing');\r\n    _api__WEBPACK_IMPORTED_MODULE_2__[\"default\"].getFileContent(e.target.dataset.id).then(res => {\r\n      App.workspace.drawings[drawingName] = res.body;\r\n      App.hideViewportMessage();\r\n      App.workspace.setDrawing(drawingName);\r\n      console.log('Drawing fetched.');\r\n    }, err => {\r\n      console.log(err);\r\n    });\r\n  }\r\n});\r\n\r\n\r\n/********************* DROPDOWNS FUNCTIONALITY *********************/\r\n\r\nconst dropdowns = document.getElementsByClassName('dropdown-container');\r\n\r\nfor (let i = 0; i < dropdowns.length; i++) {\r\n  dropdowns[i].children[0].addEventListener('click', () => {\r\n    dropdowns[i].classList.toggle('open');\r\n  });\r\n  dropdowns[i].addEventListener('mouseleave', e => {\r\n    e.currentTarget.classList.remove('open');\r\n  });\r\n}\r\n\r\n\r\n/************************ SIDE NAVE MENU ***************************/\r\n\r\nconst sideNavToggle = document.getElementById('sideNavToggle');\r\n\r\nsideNavToggle.addEventListener('click', () => {\r\n  document.getElementById('sideNavContainer').classList.toggle('active');\r\n  sideNavToggle.classList.toggle('active');\r\n});\r\n\r\n\r\n/************************* CONTEXT MENU ****************************/\r\n\r\nconst contextMenu = document.getElementById('contextMenu');\r\nlet menuVisible = false;\r\n\r\nfunction toggleMenu(command) {\r\n  contextMenu.style.display = command === \"show\" ? \"block\" : \"none\";\r\n  menuVisible = !menuVisible;\r\n}\r\n\r\nfunction setPosition({ top, left }) {\r\n  contextMenu.style.left = `${left}px`;\r\n  contextMenu.style.top = `${top}px`;\r\n  toggleMenu(\"show\");\r\n}\r\n\r\nwindow.addEventListener(\"click\", () => {\r\n  if (menuVisible) toggleMenu(\"hide\");\r\n});\r\n\r\nwindow.addEventListener(\"contextmenu\", e => {\r\n  e.preventDefault();\r\n  if (e.target.closest('[data-proj-id]')) {\r\n    // Clean previous content of the context menu.\r\n    contextMenu.querySelector('ul').childNodes.forEach(btn => btn.onclick = null);\r\n    _generics__WEBPACK_IMPORTED_MODULE_1__[\"default\"].emptyNode(contextMenu.querySelector('ul'));\r\n    // Get the id of the project.\r\n    const projectItem = e.target.closest('[data-proj-id]');\r\n    // Create the context menu buttons.\r\n    const deleteBtn = document.createElement('li');\r\n    deleteBtn.innerText = 'Delete';\r\n    deleteBtn.onclick = () => {\r\n      App.showViewportDialog('action', `Are you sure you want to delete the ${projectItem.dataset.name} project?`, [\r\n        {\r\n          name: 'Delete',\r\n          function: () => {\r\n            App.showViewportDialog('loader', `Deleting ${projectItem.dataset.name} project.`);\r\n            _api__WEBPACK_IMPORTED_MODULE_2__[\"default\"].deleteFile(projectItem.dataset.projId).then(res => {\r\n              projectItem.remove();\r\n              const index = App.projectsData.findIndex(proj => proj.id === projectItem.dataset.projId);\r\n              App.projectsData.splice(index, 1);\r\n              // TODO check also if it is in the value of currentProject or lastUploadedProject and delete it as well\r\n              App.hideViewportMessage();\r\n              showMessage('success', 'Project deleted successfully');\r\n            });\r\n          }\r\n        },\r\n        {\r\n          name: 'Cancel',\r\n          function: () => {\r\n            App.hideViewportMessage();\r\n          }\r\n        }\r\n      ]);\r\n    };\r\n    contextMenu.querySelector('ul').appendChild(deleteBtn);\r\n    const origin = {\r\n      left: e.pageX,\r\n      top: e.pageY\r\n    };\r\n    setPosition(origin);\r\n  } else {\r\n    if (menuVisible) toggleMenu(\"hide\");\r\n  }\r\n});\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/projectData.js":
/*!****************************!*\
  !*** ./src/projectData.js ***!
  \****************************/
/*! exports provided: ProjectData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ProjectData\", function() { return ProjectData; });\nclass ProjectData {\r\n  constructor() {\r\n    this.id = undefined;\r\n    this.name = undefined;\r\n    this.index = undefined; // Index in the appData.projectsData array\r\n    this.drawings = {};\r\n    this.elementsData = {};\r\n  }\r\n}\r\n\n\n//# sourceURL=webpack:///./src/projectData.js?");

/***/ }),

/***/ "./src/workspace.js":
/*!**************************!*\
  !*** ./src/workspace.js ***!
  \**************************/
/*! exports provided: Workspace */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Workspace\", function() { return Workspace; });\n/* harmony import */ var _generics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./generics */ \"./src/generics.js\");\n/* harmony import */ var _appTools_addComment__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./appTools/addComment */ \"./src/appTools/addComment.js\");\n\r\n\r\n\r\nclass Workspace {\r\n  constructor(projectData, App) {\r\n    this.projectName = projectData.name;\r\n    this.projectId = projectData.id;\r\n    this.projectIndex = App.projectsData.findIndex(obj => obj.name === projectData.name);\r\n    if (projectData.id === App.lastUploadedProject.id) {\r\n      this.drawings = App.lastUploadedProject.drawings;\r\n      this.elementsData = App.lastUploadedProject.elementsData;\r\n    } else {\r\n      this.drawings = {};\r\n      this.elementsData = {};\r\n    }\r\n    this.activeTool;\r\n    // this.toolSettings;\r\n    this.appendedDrawingsNames = [];\r\n    this.activeDrawing; // The div container with the svg drawing.\r\n    // Set title of the project in the button to list the projects.\r\n    App.projectsListBtn.innerHTML = '<span>' + projectData.name + '</span>';\r\n    this.drawingsBtns = App.drawingsBtns;\r\n    this.drawingsContainer = App.drawingsContainer;\r\n    this.createDrawingsBtns(projectData.drawings);\r\n    // Show drawings and tools buttons.\r\n    this.drawingsBtns.children[0].innerText = 'Pick a drawing';\r\n    this.drawingsBtns.style.display = 'unset';\r\n    App.toolbarsContainer.style.display = 'flex';\r\n    this.projectsData = App.projectsData;\r\n    this.commentForm = document.getElementById('commentForm');\r\n    this.comments = [];\r\n  }\r\n\r\n\r\n  /*********************** TOOLS MANAGEMENT ************************/\r\n\r\n  /**\r\n   * Sets the selected tool as active and turns off the previous one if still active.\r\n   * @param {} e\r\n   * @param {Tool} Tool \r\n   * @param {String} name \r\n   */\r\n  manageTools(e, Tool, name) { // TODO, add 'e' as param if needed\r\n    if (this.activeDrawing === undefined) {\r\n      // TODO: Show a message saying that a drawing must be active.\r\n      console.log('A drawing must be active.');\r\n      return;\r\n    }\r\n    if (this.activeTool === undefined) {\r\n      this.activeTool = new Tool(name, this);\r\n      e.currentTarget.classList.add('btn-tool-enabled');\r\n    } else if (this.activeTool.name !== name) {\r\n      this.activeTool.kill();\r\n      this.activeTool = new Tool(name, this);\r\n      e.currentTarget.classList.add('btn-tool-enabled');\r\n    } else if (this.activeTool.name === name) {\r\n      this.activeTool.kill();\r\n      this.activeTool = undefined;\r\n      e.currentTarget.classList.remove('btn-tool-enabled');\r\n    }\r\n  }\r\n\r\n\r\n  // /**\r\n  //  * Creates a comment on the drawing if it has the element on the comment obj\r\n  //  * @param {*} element \r\n  //  * @param {*} commentsGroup \r\n  //  * @param {*} comment \r\n  //  */\r\n  // createSvgComment(element, commentsGroup) {\r\n  //   const boundingBox = Generics.createBBox(element);\r\n  //   boundingBox.setAttribute('style', 'fill:none;stroke:#000;');\r\n  //   boundingBox.dataset.id = 'c-' + element.dataset.id;\r\n  //   commentsGroup.appendChild(boundingBox);\r\n  //   return boundingBox;\r\n  // }\r\n\r\n  /**\r\n   * Creates all the comments for the drawing if the commented element exists\r\n   * To be used when still there is no group for comments or if it is empty\r\n   * because it doesnt check if the element has already the comment\r\n   * @param {*} drawing \r\n   * @param {*} commentsGroup \r\n   * @param {*} comments \r\n   */\r\n  createComments(drawing, commentsGroup, comments) { // Array of comment objects\r\n    comments.forEach(comment => {\r\n      if (drawing.querySelector('[data-id=\"' + comment.elementId + '\"]') !== null) {\r\n        // Creation of the ui comment.\r\n        const element = drawing.querySelector('[data-id=\"' + comment.elementId + '\"]');\r\n        const uiComment = _appTools_addComment__WEBPACK_IMPORTED_MODULE_1__[\"AddComment\"].createSvgComment(element, commentsGroup);\r\n        comment.uiElements.push(uiComment);\r\n      }\r\n    });\r\n  }\r\n\r\n  /********************** DRAWINGS MANAGEMENT **********************/\r\n\r\n  /**\r\n   * Places the content of the svg drawing in the container.\r\n   * @param {String} drawingName \r\n   */\r\n  setDrawing(drawingName) {\r\n    // TODO: Set a default 'activeDrawing' with the 'elementsData' tool active by default? this.activeTool = new ElementsData('elementsDataTool', this);\r\n    // If there is a visible drawing hide it.\r\n    if (this.activeDrawing && this.activeDrawing.dataset.name !== drawingName) {\r\n      // If in the drawing that is going to be hided there is an element selected remove the selection.\r\n      if (this.activeTool && this.activeTool.currentSelection && this.activeDrawing.querySelector('[data-id=\"' + this.activeTool.currentSelection.dataset.id + '\"]')) {\r\n        this.activeTool.currentSelection.classList.remove('selected');\r\n      }\r\n      this.activeDrawing.style.display = 'none';\r\n    } else if (this.activeDrawing && this.activeDrawing.dataset.name === drawingName) {\r\n      return;\r\n    }\r\n    // If it is not in the container already append it. It will be visible.\r\n    if (!this.appendedDrawingsNames.includes(drawingName)) {\r\n      this.appendedDrawingsNames.push(drawingName);\r\n      const container = document.createElement('div');\r\n      container.dataset.name = drawingName;\r\n      container.style.visibility = 'hidden';\r\n      // Important: It should be appened before crating comments,\r\n      // otherwise those will not be created correclty.\r\n      this.drawingsContainer.append(container);\r\n      // Add the comments to the svg if there are any.\r\n      if (this.comments.length > 0) {\r\n        const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');\r\n        group.setAttribute('comments', '');\r\n        // TODO: Set visibility\r\n        const domparser = new DOMParser();\r\n        const svg = domparser.parseFromString(this.drawings[drawingName], 'image/svg+xml').documentElement;\r\n        // Append everything before creating the comments.\r\n        container.appendChild(svg);\r\n        svg.appendChild(group);\r\n        this.createComments(svg, group, this.comments);\r\n      } else {\r\n        container.innerHTML = this.drawings[drawingName];\r\n      }\r\n      this.activeDrawing = container;\r\n      this.activeDrawing.style.visibility = 'unset';\r\n    } else {\r\n      this.activeDrawing = this.drawingsContainer.querySelector('div[data-name=\"' + drawingName + '\"]');\r\n      // Browers like Chrome doesnt calculate svg if it is display none, that why\r\n      // I change it for visibility while I add the comments if any. \r\n      this.activeDrawing.style.visibility = 'hidden';\r\n      this.activeDrawing.style.display = 'unset';\r\n      // If there are comments check if anyone is missing.\r\n      if (this.comments.length > 0) {\r\n        if (this.activeDrawing.querySelector('g[comments]') !== null) {\r\n          const svgCommentsGroup = this.activeDrawing.querySelector('g[comments]');\r\n          // Si ya tiene grupo entonces actualizar visibilidad y actualizar sus contenidos\r\n          // Comprobar si ya existe un comentario para el elemento, sino crearlo\r\n          this.comments.forEach(comment => {\r\n            if (svgCommentsGroup.querySelector('[data-id=\"' + comment.id + '\"]') === null) {\r\n              // Creation if the ui comment.\r\n              const element = this.activeDrawing.querySelector('[data-id=\"' + comment.elementId + '\"]');\r\n              const uiComment = _appTools_addComment__WEBPACK_IMPORTED_MODULE_1__[\"AddComment\"].createSvgComment(element, svgCommentsGroup);\r\n              comment.uiElements.push(uiComment);\r\n            }\r\n          });\r\n        } else {\r\n          const group = document.createElementNS('http://www.w3.org/2000/svg', 'g');\r\n          group.setAttribute('comments', '');\r\n          // TODO: Set visibility\r\n          this.activeDrawing.querySelector('svg').appendChild(group);\r\n          this.createComments(this.activeDrawing, group, this.comments);\r\n        }\r\n      }\r\n      this.activeDrawing.style.visibility = 'unset';\r\n    }\r\n    // Update also the 'activeDrawing' in the 'activeTool'.\r\n    if (this.activeTool) { this.activeTool.activeDrawing = this.activeDrawing; }\r\n    if (this.activeTool && this.activeTool.currentSelection && this.activeDrawing.querySelector('[data-id=\"' + this.activeTool.currentSelection.dataset.id + '\"]')) {\r\n      this.activeTool.currentSelection = this.activeDrawing.querySelector('[data-id=\"' + this.activeTool.currentSelection.dataset.id + '\"]');\r\n      this.activeTool.currentSelection.classList.add('selected');\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Creates the buttons for the drawings to be displayed.\r\n   * @param {Object} drawings Object with the drawings, each entry has the name as key.\r\n   */\r\n  createDrawingsBtns(drawings) {\r\n    let drawingsItems = [];\r\n    for (const drawingName in drawings) {\r\n      // Could be that there is no id if the project was uploaded and it is only local.\r\n      drawingsItems.push(`<li ${drawings[drawingName].id ? 'data-id=\\\"' + drawings[drawingName].id + '\\\"' : ''}>${drawingName}</li>`);\r\n    }\r\n    this.drawingsBtns.querySelector('.dropdown-content').innerHTML = drawingsItems.join('');\r\n  }\r\n\r\n  /**\r\n   * Cleans the workspace by emptying the drawing container and the list of drawings.\r\n   * TODO: Remove possible event listeners before emptying containers ?\r\n   */\r\n  close() {\r\n    _generics__WEBPACK_IMPORTED_MODULE_0__[\"default\"].emptyNode(this.drawingsBtns.querySelector('.dropdown-content'));\r\n    // TODO: If in future version there are elements in the svg with event listeners those should be deleted\r\n    this.drawingsContainer.innerHTML = '';\r\n  }\r\n}\n\n//# sourceURL=webpack:///./src/workspace.js?");

/***/ })

/******/ });